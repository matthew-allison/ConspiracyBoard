# 1754 Operators

# Simplify F-Curves by removing closely spaced keyframes
bpy.ops.action.clean(threshold=0.001, channels=False)
# Select keyframes by clicking on them
bpy.ops.action.clickselect(extend=False, column=False, channel=False)
# Copy selected keyframes to the copy/paste buffer
bpy.ops.action.copy()
# Remove all selected keyframes
bpy.ops.action.delete()
# Make a copy of all selected keyframes
bpy.ops.action.duplicate()
# Make a copy of all selected keyframes and move them
bpy.ops.action.duplicate_move(ACTION_OT_duplicate={}, TRANSFORM_OT_transform={"mode":'TRANSLATION', "value":(0, 0, 0, 0), "axis":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "release_confirm":False, "use_accurate":False})
# Set extrapolation mode for selected F-Curves
bpy.ops.action.extrapolation_type(type='CONSTANT')
# Set the current frame to the average frame value of selected keyframes
bpy.ops.action.frame_jump()
# Set type of handle for selected keyframes
bpy.ops.action.handle_type(type='FREE')
# Set interpolation mode for the F-Curve segments starting from the selected keyframes
bpy.ops.action.interpolation_type(type='CONSTANT')
# Insert keyframes for the specified channels
bpy.ops.action.keyframe_insert(type='ALL')
# Set type of keyframe for the selected keyframes
bpy.ops.action.keyframe_type(type='KEYFRAME')
# Switch to editing action in animation layer above the current action in the NLA Stack
bpy.ops.action.layer_next()
# Switch to editing action in animation layer below the current action in the NLA Stack
bpy.ops.action.layer_prev()
# Move selected scene markers to the active Action as local 'pose' markers
bpy.ops.action.markers_make_local()
# Flip selected keyframes over the selected mirror line
bpy.ops.action.mirror(type='CFRA')
# Create new action
bpy.ops.action.new()
# Paste keyframes from copy/paste buffer for the selected channels, starting on the current frame
bpy.ops.action.paste(offset='START', merge='MIX', flipped=False)
# Set Preview Range based on extents of selected Keyframes
bpy.ops.action.previewrange_set()
# Toggle the properties region visibility
bpy.ops.action.properties()
# Push action down on to the NLA stack as a new strip
bpy.ops.action.push_down()
# Add keyframes on every frame between the selected keyframes
bpy.ops.action.sample()
# Toggle selection of all keyframes
bpy.ops.action.select_all_toggle(invert=False)
# Select all keyframes within the specified region
bpy.ops.action.select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True, axis_range=False)
# Select keyframe points using circle selection
bpy.ops.action.select_circle(x=0, y=0, radius=1, gesture_mode=0)
# Select all keyframes on the specified frame(s)
bpy.ops.action.select_column(mode='KEYS')
# Select keyframe points using lasso selection
bpy.ops.action.select_lasso(path=[], deselect=False, extend=True)
# Select keyframes to the left or the right of the current frame
bpy.ops.action.select_leftright(mode='CHECK', extend=False)
# Deselect keyframes on ends of selection islands
bpy.ops.action.select_less()
# Select keyframes occurring in the same F-Curves as selected ones
bpy.ops.action.select_linked()
# Select keyframes beside already selected ones
bpy.ops.action.select_more()
# Snap selected keyframes to the times specified
bpy.ops.action.snap(type='CFRA')
# Store this action in the NLA stack as a non-contributing strip for later use
bpy.ops.action.stash(create_new=True)
# Store this action in the NLA stack as a non-contributing strip for later use, and create a new action
bpy.ops.action.stash_and_create()
# Unlink this action from the active action slot (and/or exit Tweak Mode)
bpy.ops.action.unlink(force_delete=False)
# Reset viewable area to show full keyframe range
bpy.ops.action.view_all()
# Reset viewable area to show range around current frame
bpy.ops.action.view_frame()
# Reset viewable area to show selected keyframes range
bpy.ops.action.view_selected()

# Interactively change the current frame number
bpy.ops.anim.change_frame(frame=0, snap=False)
# Select all keyframes of channel under mouse
bpy.ops.anim.channel_select_keys(extend=False)
# Delete all empty animation data containers from visible data-blocks
bpy.ops.anim.channels_clean_empty()
# Handle mouse-clicks over animation channels
bpy.ops.anim.channels_click(extend=False, children_only=False)
# Collapse (i.e. close) all selected expandable animation channels
bpy.ops.anim.channels_collapse(all=True)
# Delete all selected animation channels
bpy.ops.anim.channels_delete()
# Toggle editability of selected channels
bpy.ops.anim.channels_editable_toggle(mode='TOGGLE', type='PROTECT')
# Expand (i.e. open) all selected expandable animation channels
bpy.ops.anim.channels_expand(all=True)
# Clears 'disabled' tag from all F-Curves to get broken F-Curves working again
bpy.ops.anim.channels_fcurves_enable()
# Filter the set of channels shown to only include those with matching names
bpy.ops.anim.channels_find(query="Query")
# Add selected F-Curves to a new group
bpy.ops.anim.channels_group(name="New Group")
# Rearrange selected animation channels
bpy.ops.anim.channels_move(direction='DOWN')
# Rename animation channel under mouse
bpy.ops.anim.channels_rename()
# Toggle selection of all animation channels
bpy.ops.anim.channels_select_all_toggle(invert=False)
# Select all animation channels within the specified region
bpy.ops.anim.channels_select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
# Disable specified setting on all selected animation channels
bpy.ops.anim.channels_setting_disable(mode='DISABLE', type='PROTECT')
# Enable specified setting on all selected animation channels
bpy.ops.anim.channels_setting_enable(mode='ENABLE', type='PROTECT')
# Toggle specified setting on all selected animation channels
bpy.ops.anim.channels_setting_toggle(mode='TOGGLE', type='PROTECT')
# Remove selected F-Curves from their current groups
bpy.ops.anim.channels_ungroup()
# Mark actions with no F-Curves for deletion after save & reload of file preserving "action libraries"
bpy.ops.anim.clear_useless_actions(only_unused=True)
# Copy the driver for the highlighted button
bpy.ops.anim.copy_driver_button()
# Add driver(s) for the property(s) represented by the highlighted button
bpy.ops.anim.driver_button_add(mapping_type='SINGLE_MANY')
# Remove the driver(s) for the property(s) connected represented by the highlighted button
bpy.ops.anim.driver_button_remove(all=True)
# Clear all keyframes on the currently active property
bpy.ops.anim.keyframe_clear_button(all=True)
# Remove all keyframe animation for selected objects
bpy.ops.anim.keyframe_clear_v3d()
# Delete keyframes on the current frame for all properties in the specified Keying Set
bpy.ops.anim.keyframe_delete(type='DEFAULT', confirm_success=True)
# Delete current keyframe of current UI-active property
bpy.ops.anim.keyframe_delete_button(all=True)
# Remove keyframes on current frame for selected objects and bones
bpy.ops.anim.keyframe_delete_v3d()
# Insert keyframes on the current frame for all properties in the specified Keying Set
bpy.ops.anim.keyframe_insert(type='DEFAULT', confirm_success=True)
# Insert a keyframe for current UI-active property
bpy.ops.anim.keyframe_insert_button(all=True)
# Insert Keyframes for specified Keying Set, with menu of available Keying Sets if undefined
bpy.ops.anim.keyframe_insert_menu(type='DEFAULT', confirm_success=False, always_prompt=False)
# Select a new keying set as the active one
bpy.ops.anim.keying_set_active_set(type='DEFAULT')
# Add a new (empty) Keying Set to the active Scene
bpy.ops.anim.keying_set_add()
# Export Keying Set to a python script
bpy.ops.anim.keying_set_export(filepath="", filter_folder=True, filter_text=True, filter_python=True)
# Add empty path to active Keying Set
bpy.ops.anim.keying_set_path_add()
# Remove active Path from active Keying Set
bpy.ops.anim.keying_set_path_remove()
# Remove the active Keying Set
bpy.ops.anim.keying_set_remove()
# Add current UI-active property to current keying set
bpy.ops.anim.keyingset_button_add(all=True)
# Remove current UI-active property from current keying set
bpy.ops.anim.keyingset_button_remove()
# Paste the driver in the copy/paste buffer for the highlighted button
bpy.ops.anim.paste_driver_button()
# Clear Preview Range
bpy.ops.anim.previewrange_clear()
# Interactively define frame range used for playback
bpy.ops.anim.previewrange_set(xmin=0, xmax=0, ymin=0, ymax=0)
# Update fcurves/drivers affecting Transform constraints (use it with files from 2.70 and earlier)
bpy.ops.anim.update_animated_transform_constraints(use_convert_to_radians=True)

# Align selected bones to the active bone (or to their parent)
bpy.ops.armature.align()
# Change the visible armature layers
bpy.ops.armature.armature_layers(layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Automatically renames the selected bones according to which side of the target axis they fall on
bpy.ops.armature.autoside_names(type='XAXIS')
# Change the layers that the selected bones belong to
bpy.ops.armature.bone_layers(layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Add a new bone located at the 3D-Cursor
bpy.ops.armature.bone_primitive_add(name="Bone")
# Automatically fix alignment of select bones' axes
bpy.ops.armature.calculate_roll(type='POS_X', axis_flip=False, axis_only=False)
# Create a new bone going from the last selected joint to the mouse position
bpy.ops.armature.click_extrude()
# Remove selected bones from the armature
bpy.ops.armature.delete()
# Dissolve selected bones from the armature
bpy.ops.armature.dissolve()
# Make copies of the selected bones within the same armature
bpy.ops.armature.duplicate()
# Make copies of the selected bones within the same armature and move them
bpy.ops.armature.duplicate_move(ARMATURE_OT_duplicate={}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Create new bones from the selected joints
bpy.ops.armature.extrude(forked=False)
# Create new bones from the selected joints and move them
bpy.ops.armature.extrude_forked(ARMATURE_OT_extrude={"forked":False}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Create new bones from the selected joints and move them
bpy.ops.armature.extrude_move(ARMATURE_OT_extrude={"forked":False}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Add bone between selected joint(s) and/or 3D-Cursor
bpy.ops.armature.fill()
# Flips (and corrects) the axis suffixes of the names of selected bones
bpy.ops.armature.flip_names()
# Tag selected bones to not be visible in Edit Mode
bpy.ops.armature.hide(unselected=False)
# Make all armature layers visible
bpy.ops.armature.layers_show_all(all=True)
# Merge continuous chains of selected bones
bpy.ops.armature.merge(type='WITHIN_CHAIN')
# Remove the parent-child relationship between selected bones and their parents
bpy.ops.armature.parent_clear(type='CLEAR')
# Set the active bone as the parent of the selected bones
bpy.ops.armature.parent_set(type='CONNECTED')
# Unhide all bones that have been tagged to be hidden in Edit Mode
bpy.ops.armature.reveal()
# Clear roll for selected bones
bpy.ops.armature.roll_clear(roll=0)
# Toggle selection status of all bones
bpy.ops.armature.select_all(action='TOGGLE')
# Select immediate parent/children of selected bones
bpy.ops.armature.select_hierarchy(direction='PARENT', extend=False)
# Deselect those bones at the boundary of each selection region
bpy.ops.armature.select_less()
# Select bones related to selected ones by parent/child relationships
bpy.ops.armature.select_linked(extend=False)
# Mirror the bone selection
bpy.ops.armature.select_mirror(only_active=False, extend=False)
# Select those bones connected to the initial selection
bpy.ops.armature.select_more()
# Select similar bones by property types
bpy.ops.armature.select_similar(type='LENGTH', threshold=0.1)
# Isolate selected bones into a separate armature
bpy.ops.armature.separate()
# Select shortest path between two bones
bpy.ops.armature.shortest_path_pick()
# Split off selected bones from connected unselected bones
bpy.ops.armature.split()
# Break selected bones into chains of smaller bones
bpy.ops.armature.subdivide(number_cuts=1)
# Change the direction that a chain of bones points in (head <-> tail swap)
bpy.ops.armature.switch_direction()
# Enforce symmetry, make copies of the selection or use existing
bpy.ops.armature.symmetrize(direction='NEGATIVE_X')

# Add a boid rule to the current boid state
bpy.ops.boid.rule_add(type='GOAL')
# Delete current boid rule
bpy.ops.boid.rule_del()
# Move boid rule down in the list
bpy.ops.boid.rule_move_down()
# Move boid rule up in the list
bpy.ops.boid.rule_move_up()
# Add a boid state to the particle system
bpy.ops.boid.state_add()
# Delete current boid state
bpy.ops.boid.state_del()
# Move boid state down in the list
bpy.ops.boid.state_move_down()
# Move boid state up in the list
bpy.ops.boid.state_move_up()

# Set active sculpt/paint brush from it's number
bpy.ops.brush.active_index_set(mode="", index=0)
# Add brush by mode type
bpy.ops.brush.add()
# Set brush shape
bpy.ops.brush.curve_preset(shape='SMOOTH')
# Return brush to defaults based on current tool
bpy.ops.brush.reset()
# Change brush size by a scalar
bpy.ops.brush.scale_size(scalar=1)
# Control the stencil brush
bpy.ops.brush.stencil_control(mode='TRANSLATION', texmode='PRIMARY')
# When using an image texture, adjust the stencil size to fit the image aspect ratio
bpy.ops.brush.stencil_fit_image_aspect(use_repeat=True, use_scale=True, mask=False)
# Reset the stencil transformation to the default
bpy.ops.brush.stencil_reset_transform(mask=False)
# Set the UV sculpt tool
bpy.ops.brush.uv_sculpt_tool_set(tool='PINCH')

# Open a directory browser, Hold Shift to open the file, Alt to browse containing directory
bpy.ops.buttons.directory_browse(directory="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=False, filter_blenlib=False, filemode=9, relative_path=True, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA')
# Open a file browser, Hold Shift to open the file, Alt to browse containing directory
bpy.ops.buttons.file_browse(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=False, filter_blenlib=False, filemode=9, relative_path=True, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA')
# Display button panel toolbox
bpy.ops.buttons.toolbox()

# Load a cache file
bpy.ops.cachefile.open(filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=True, filter_folder=True, filter_blenlib=False, filemode=8, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA')
# Update objects paths list with new data from the archive
bpy.ops.cachefile.reload()

# Add or remove a Camera Preset
bpy.ops.camera.preset_add(name="", remove_active=False, use_focal_length=False)

# Place new marker at specified location
bpy.ops.clip.add_marker(location=(0, 0))
# Place new marker at the desired (clicked) position
bpy.ops.clip.add_marker_at_click()
# Add new marker and move it on movie
bpy.ops.clip.add_marker_move(CLIP_OT_add_marker={"location":(0, 0)}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Add new marker and slide it with mouse until mouse button release
bpy.ops.clip.add_marker_slide(CLIP_OT_add_marker={"location":(0, 0)}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Apply scale on solution itself to make distance between selected tracks equals to desired
bpy.ops.clip.apply_solution_scale(distance=0)
# Create vertex cloud using coordinates of reconstructed tracks
bpy.ops.clip.bundles_to_mesh()
# Add or remove a Tracking Camera Intrinsics Preset
bpy.ops.clip.camera_preset_add(name="", remove_active=False, use_focal_length=True)
# Interactively change the current frame number
bpy.ops.clip.change_frame(frame=0)
# Clean tracks with high error values or few frames
bpy.ops.clip.clean_tracks(frames=0, error=0, action='SELECT')
# Clear all calculated data
bpy.ops.clip.clear_solution()
# Clear tracks after/before current position or clear the whole track
bpy.ops.clip.clear_track_path(action='REMAINED', clear_active=False)
# Create F-Curves for object which will copy object's movement caused by this constraint
bpy.ops.clip.constraint_to_fcurve()
# Copy selected tracks to clipboard
bpy.ops.clip.copy_tracks()
# Create new plane track out of selected point tracks
bpy.ops.clip.create_plane_track()
# Set 2D cursor location
bpy.ops.clip.cursor_set(location=(0, 0))
# Delete marker for current frame from selected tracks
bpy.ops.clip.delete_marker()
# Delete movie clip proxy files from the hard drive
bpy.ops.clip.delete_proxy()
# Delete selected tracks
bpy.ops.clip.delete_track()
# Automatically detect features and place markers to track
bpy.ops.clip.detect_features(placement='FRAME', margin=16, threshold=0.5, min_distance=120)
# Disable/enable selected markers
bpy.ops.clip.disable_markers(action='DISABLE')
# Select movie tracking channel
bpy.ops.clip.dopesheet_select_channel(location=(0, 0), extend=False)
# Reset viewable area to show full keyframe range
bpy.ops.clip.dopesheet_view_all()
# Filter tracks which has weirdly looking spikes in motion curves
bpy.ops.clip.filter_tracks(track_threshold=5)
# Jump to special frame
bpy.ops.clip.frame_jump(position='PATHSTART')
# Scroll view so current frame would be centered
bpy.ops.clip.graph_center_current_frame()
# Delete track corresponding to the selected curve
bpy.ops.clip.graph_delete_curve()
# Delete curve knots
bpy.ops.clip.graph_delete_knot()
# Disable/enable selected markers
bpy.ops.clip.graph_disable_markers(action='DISABLE')
# Select graph curves
bpy.ops.clip.graph_select(location=(0, 0), extend=False)
# Change selection of all markers of active track
bpy.ops.clip.graph_select_all_markers(action='TOGGLE')
# Select curve points using border selection
bpy.ops.clip.graph_select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
# View all curves in editor
bpy.ops.clip.graph_view_all()
# Hide selected tracks
bpy.ops.clip.hide_tracks(unselected=False)
# Clear hide selected tracks
bpy.ops.clip.hide_tracks_clear()
# Join selected tracks
bpy.ops.clip.join_tracks()
# Delete a keyframe from selected tracks at current frame
bpy.ops.clip.keyframe_delete()
# Insert a keyframe to selected tracks at current frame
bpy.ops.clip.keyframe_insert()
# Lock/unlock selected tracks
bpy.ops.clip.lock_tracks(action='LOCK')
# Set the clip interaction mode
bpy.ops.clip.mode_set(mode='TRACKING')
# Load a sequence of frames or a movie file
bpy.ops.clip.open(directory="", files=[], filter_blender=False, filter_backup=False, filter_image=True, filter_movie=True, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, relative_path=True, show_multiview=False, use_multiview=False, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA')
# Paste tracks from clipboard
bpy.ops.clip.paste_tracks()
# Prefetch frames from disk for faster playback/tracking
bpy.ops.clip.prefetch()
# Toggle the properties region visibility
bpy.ops.clip.properties()
# Rebuild all selected proxies and timecode indices in the background
bpy.ops.clip.rebuild_proxy()
# Refine selected markers positions by running the tracker from track's reference to current frame
bpy.ops.clip.refine_markers(backwards=False)
# Reload clip
bpy.ops.clip.reload()
# Select tracking markers
bpy.ops.clip.select(extend=False, location=(0, 0))
# Change selection of all tracking markers
bpy.ops.clip.select_all(action='TOGGLE')
# Select markers using border selection
bpy.ops.clip.select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
# Select markers using circle selection
bpy.ops.clip.select_circle(x=0, y=0, radius=1, gesture_mode=0)
# Select all tracks from specified group
bpy.ops.clip.select_grouped(group='ESTIMATED')
# Select markers using lasso selection
bpy.ops.clip.select_lasso(path=[], deselect=False, extend=True)
#
bpy.ops.clip.set_active_clip()
# Set direction of scene axis rotating camera (or its parent if present) and assume selected track lies on real axis, joining it with the origin
bpy.ops.clip.set_axis(axis='X')
# Set optical center to center of footage
bpy.ops.clip.set_center_principal()
# Set active marker as origin by moving camera (or its parent if present) in 3D space
bpy.ops.clip.set_origin(use_median=False)
# Set plane based on 3 selected bundles by moving camera (or its parent if present) in 3D space
bpy.ops.clip.set_plane(plane='FLOOR')
# Set scale of scene by scaling camera (or its parent if present)
bpy.ops.clip.set_scale(distance=0)
# Set scene's start and end frame to match clip's start frame and length
bpy.ops.clip.set_scene_frames()
# Set object solution scale using distance between two selected tracks
bpy.ops.clip.set_solution_scale(distance=0)
# Set keyframe used by solver
bpy.ops.clip.set_solver_keyframe(keyframe='KEYFRAME_A')
# Set current movie clip as a camera background in 3D view-port (works only when a 3D view-port is visible)
bpy.ops.clip.set_viewport_background()
# Prepare scene for compositing 3D objects into this footage
bpy.ops.clip.setup_tracking_scene()
# Slide marker areas
bpy.ops.clip.slide_marker(offset=(0, 0))
# Slide plane marker areas
bpy.ops.clip.slide_plane_marker()
# Solve camera motion from tracks
bpy.ops.clip.solve_camera()
# Add selected tracks to 2D translation stabilization
bpy.ops.clip.stabilize_2d_add()
# Remove selected track from translation stabilization
bpy.ops.clip.stabilize_2d_remove()
# Add selected tracks to 2D rotation stabilization
bpy.ops.clip.stabilize_2d_rotation_add()
# Remove selected track from rotation stabilization
bpy.ops.clip.stabilize_2d_rotation_remove()
# Select tracks which are used for rotation stabilization
bpy.ops.clip.stabilize_2d_rotation_select()
# Select tracks which are used for translation stabilization
bpy.ops.clip.stabilize_2d_select()
# Toggle clip tools panel
bpy.ops.clip.tools()
# Add or remove a Clip Track Color Preset
bpy.ops.clip.track_color_preset_add(name="", remove_active=False)
# Copy color to all selected tracks
bpy.ops.clip.track_copy_color()
# Track selected markers
bpy.ops.clip.track_markers(backwards=False, sequence=False)
# Copy tracking settings from active track to default settings
bpy.ops.clip.track_settings_as_default()
# Copy tracking settings from active track to selected tracks
bpy.ops.clip.track_settings_to_track()
# Create an Empty object which will be copying movement of active track
bpy.ops.clip.track_to_empty()
# Add new object for tracking
bpy.ops.clip.tracking_object_new()
# Remove object for tracking
bpy.ops.clip.tracking_object_remove()
# Add or remove a motion tracking settings preset
bpy.ops.clip.tracking_settings_preset_add(name="", remove_active=False)
# View whole image with markers
bpy.ops.clip.view_all(fit_view=False)
# Use a 3D mouse device to pan/zoom the view
bpy.ops.clip.view_ndof()
# Pan the view
bpy.ops.clip.view_pan(offset=(0, 0))
# View all selected elements
bpy.ops.clip.view_selected()
# Zoom in/out the view
bpy.ops.clip.view_zoom(factor=0)
# Zoom in the view
bpy.ops.clip.view_zoom_in(location=(0, 0))
# Zoom out the view
bpy.ops.clip.view_zoom_out(location=(0, 0))
# Set the zoom ratio (based on clip size)
bpy.ops.clip.view_zoom_ratio(ratio=0)

# Add or remove a Cloth Preset
bpy.ops.cloth.preset_add(name="", remove_active=False)

# Evaluate the namespace up until the cursor and give a list of options or complete the name if there is only one
bpy.ops.console.autocomplete()
# Print a message when the terminal initializes
bpy.ops.console.banner()
# Clear text by type
bpy.ops.console.clear(scrollback=True, history=False)
# Clear the line and store in history
bpy.ops.console.clear_line()
# Copy selected text to clipboard
bpy.ops.console.copy()
# Copy the console contents for use in a script
bpy.ops.console.copy_as_script()
# Delete text by cursor position
bpy.ops.console.delete(type='NEXT_CHARACTER')
# Execute the current console line as a python expression
bpy.ops.console.execute(interactive=False)
# Append history at cursor position
bpy.ops.console.history_append(text="", current_character=0, remove_duplicates=False)
# Cycle through history
bpy.ops.console.history_cycle(reverse=False)
# Add 4 spaces at line beginning
bpy.ops.console.indent()
# Insert text at cursor position
bpy.ops.console.insert(text="")
# Set the current language for this console
bpy.ops.console.language(language="")
# Move cursor position
bpy.ops.console.move(type='LINE_BEGIN')
# Paste text from clipboard
bpy.ops.console.paste()
# Append scrollback text by type
bpy.ops.console.scrollback_append(text="", type='OUTPUT')
# Set the console selection
bpy.ops.console.select_set()
# Select word at cursor position
bpy.ops.console.select_word()
# Delete 4 spaces from line beginning
bpy.ops.console.unindent()

# Clear inverse correction for ChildOf constraint
bpy.ops.constraint.childof_clear_inverse(constraint="", owner='OBJECT')
# Set inverse correction for ChildOf constraint
bpy.ops.constraint.childof_set_inverse(constraint="", owner='OBJECT')
# Remove constraint from constraint stack
bpy.ops.constraint.delete()
# Add default animation for path used by constraint if it isn't animated already
bpy.ops.constraint.followpath_path_animate(constraint="", owner='OBJECT', frame_start=1, length=100)
# Reset limiting distance for Limit Distance Constraint
bpy.ops.constraint.limitdistance_reset(constraint="", owner='OBJECT')
# Move constraint down in constraint stack
bpy.ops.constraint.move_down(constraint="", owner='OBJECT')
# Move constraint up in constraint stack
bpy.ops.constraint.move_up(constraint="", owner='OBJECT')
# Clear inverse correction for ObjectSolver constraint
bpy.ops.constraint.objectsolver_clear_inverse(constraint="", owner='OBJECT')
# Set inverse correction for ObjectSolver constraint
bpy.ops.constraint.objectsolver_set_inverse(constraint="", owner='OBJECT')
# Reset original length of bone for Stretch To Constraint
bpy.ops.constraint.stretchto_reset(constraint="", owner='OBJECT')

# Make active spline closed/opened loop
bpy.ops.curve.cyclic_toggle(direction='CYCLIC_U')
# (De)select first of visible part of each NURBS
bpy.ops.curve.de_select_first()
# (De)select last of visible part of each NURBS
bpy.ops.curve.de_select_last()
# Delete selected control points or segments
bpy.ops.curve.delete(type='VERT')
# Delete selected control points, correcting surrounding handles
bpy.ops.curve.dissolve_verts()
# Draw a freehand spline
bpy.ops.curve.draw(error_threshold=0, fit_method='REFIT', corner_angle=1.22173, use_cyclic=True, stroke=[], wait_for_input=True)
# Duplicate selected control points
bpy.ops.curve.duplicate()
# Duplicate curve and move
bpy.ops.curve.duplicate_move(CURVE_OT_duplicate={}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Extrude selected control point(s)
bpy.ops.curve.extrude(mode='TRANSLATION')
# Extrude curve and move result
bpy.ops.curve.extrude_move(CURVE_OT_extrude={"mode":'TRANSLATION'}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Set type of handles for selected control points
bpy.ops.curve.handle_type_set(type='AUTOMATIC')
# Hide (un)selected control points
bpy.ops.curve.hide(unselected=False)
# Join two curves by their selected ends
bpy.ops.curve.make_segment()
# Match texture space to object's bounding box
bpy.ops.curve.match_texture_space()
# Recalculate the direction of selected handles
bpy.ops.curve.normals_make_consistent(calc_length=False)
# Construct a Bezier Circle
bpy.ops.curve.primitive_bezier_circle_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Construct a Bezier Curve
bpy.ops.curve.primitive_bezier_curve_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Construct a Nurbs Circle
bpy.ops.curve.primitive_nurbs_circle_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Construct a Nurbs Curve
bpy.ops.curve.primitive_nurbs_curve_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Construct a Path
bpy.ops.curve.primitive_nurbs_path_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Set per-point radius which is used for bevel tapering
bpy.ops.curve.radius_set(radius=1)
# Show again hidden control points
bpy.ops.curve.reveal()
# (De)select all control points
bpy.ops.curve.select_all(action='TOGGLE')
# Reduce current selection by deselecting boundary elements
bpy.ops.curve.select_less()
# Select all control points linked to active one
bpy.ops.curve.select_linked()
# Select all control points linked to already selected ones
bpy.ops.curve.select_linked_pick(deselect=False)
# Select control points directly linked to already selected ones
bpy.ops.curve.select_more()
# Select control points following already selected ones along the curves
bpy.ops.curve.select_next()
# Deselect every other vertex
bpy.ops.curve.select_nth(nth=2, skip=1, offset=0)
# Select control points preceding already selected ones along the curves
bpy.ops.curve.select_previous()
# Randomly select some control points
bpy.ops.curve.select_random(percent=50, seed=0, action='SELECT')
# Select a row of control points including active one
bpy.ops.curve.select_row()
# Select similar curve points by property type
bpy.ops.curve.select_similar(type='WEIGHT', compare='EQUAL', threshold=0.1)
# Separate selected points from connected unselected points into a new object
bpy.ops.curve.separate()
# Set shading to flat
bpy.ops.curve.shade_flat()
# Set shading to smooth
bpy.ops.curve.shade_smooth()
# Select shortest path between two selections
bpy.ops.curve.shortest_path_pick()
# Flatten angles of selected points
bpy.ops.curve.smooth()
# Interpolate radii of selected points
bpy.ops.curve.smooth_radius()
# Interpolate tilt of selected points
bpy.ops.curve.smooth_tilt()
# Interpolate weight of selected points
bpy.ops.curve.smooth_weight()
# Extrude selected boundary row around pivot point and current view axis
bpy.ops.curve.spin(center=(0, 0, 0), axis=(0, 0, 0))
# Set type of active spline
bpy.ops.curve.spline_type_set(type='POLY', use_handles=False)
# Set softbody goal weight for selected points
bpy.ops.curve.spline_weight_set(weight=1)
# Split off selected points from connected unselected points
bpy.ops.curve.split()
# Subdivide selected segments
bpy.ops.curve.subdivide(number_cuts=1)
# Switch direction of selected splines
bpy.ops.curve.switch_direction()
# Clear the tilt of selected control points
bpy.ops.curve.tilt_clear()
# Add a new control point (linked to only selected end-curve one, if any)
bpy.ops.curve.vertex_add(location=(0, 0, 0))

# Enable nodes on a material, world or lamp
bpy.ops.cycles.use_shading_nodes()

# Bake dynamic paint image sequence surface
bpy.ops.dpaint.bake()
# Add or remove Dynamic Paint output data layer
bpy.ops.dpaint.output_toggle(output='A')
# Add a new Dynamic Paint surface slot
bpy.ops.dpaint.surface_slot_add()
# Remove the selected surface slot
bpy.ops.dpaint.surface_slot_remove()
# Toggle whether given type is active or not
bpy.ops.dpaint.type_toggle(type='CANVAS')

# Flush edit data from active editing modes
bpy.ops.ed.flush_edits()
# Redo previous action
bpy.ops.ed.redo()
# Undo previous action
bpy.ops.ed.undo()
# Redo specific action in history
bpy.ops.ed.undo_history(item=0)
# Add an undo state (internal use only)
bpy.ops.ed.undo_push(message="Add an undo step *function may be moved*")
# Undo and redo previous action
bpy.ops.ed.undo_redo()

# Save a BVH motion capture file from an armature
bpy.ops.export_anim.bvh(filepath="", check_existing=True, filter_glob="*.bvh", global_scale=1, frame_start=0, frame_end=0, rotate_mode='NATIVE', root_transform_only=False)

# Export a single object as a Stanford PLY with normals, colors and texture coordinates
bpy.ops.export_mesh.ply(filepath="", check_existing=True, axis_forward='Y', axis_up='Z', filter_glob="*.ply", use_mesh_modifiers=True, use_normals=True, use_uv_coords=True, use_colors=True, global_scale=1)
# Save STL triangle mesh data from the active object
bpy.ops.export_mesh.stl(filepath="", check_existing=True, axis_forward='Y', axis_up='Z', filter_glob="*.stl", use_selection=False, global_scale=1, use_scene_unit=False, ascii=False, use_mesh_modifiers=True, batch_mode='OFF')

# Export to 3DS file format (.3ds)
bpy.ops.export_scene.autodesk_3ds(filepath="", check_existing=True, axis_forward='Y', axis_up='Z', filter_glob="*.3ds", use_selection=False)
# Write a FBX file
bpy.ops.export_scene.fbx(filepath="", check_existing=True, axis_forward='-Z', axis_up='Y', filter_glob="*.fbx", version='BIN7400', ui_tab='MAIN', use_selection=False, global_scale=1, apply_unit_scale=True, apply_scale_options='FBX_SCALE_NONE', bake_space_transform=False, object_types={'EMPTY', 'CAMERA', 'LAMP', 'ARMATURE', 'MESH', 'OTHER'}, use_mesh_modifiers=True, use_mesh_modifiers_render=True, mesh_smooth_type='OFF', use_mesh_edges=False, use_tspace=False, use_custom_props=False, add_leaf_bones=True, primary_bone_axis='Y', secondary_bone_axis='X', use_armature_deform_only=False, armature_nodetype='NULL', bake_anim=True, bake_anim_use_all_bones=True, bake_anim_use_nla_strips=True, bake_anim_use_all_actions=True, bake_anim_force_startend_keying=True, bake_anim_step=1, bake_anim_simplify_factor=1, use_anim=True, use_anim_action_all=True, use_default_take=True, use_anim_optimize=True, anim_optimize_precision=6, path_mode='AUTO', embed_textures=False, batch_mode='OFF', use_batch_own_dir=True, use_metadata=True)
# Save a Wavefront OBJ File
bpy.ops.export_scene.obj(filepath="", check_existing=True, axis_forward='-Z', axis_up='Y', filter_glob="*.obj;*.mtl", use_selection=False, use_animation=False, use_mesh_modifiers=True, use_mesh_modifiers_render=False, use_edges=True, use_smooth_groups=False, use_smooth_groups_bitflags=False, use_normals=True, use_uvs=True, use_materials=True, use_triangles=False, use_nurbs=False, use_vertex_groups=False, use_blen_objects=True, group_by_object=False, group_by_material=False, keep_vertex_order=False, global_scale=1, path_mode='AUTO')
# Export selection to Extensible 3D file (.x3d)
bpy.ops.export_scene.x3d(filepath="", check_existing=True, axis_forward='Z', axis_up='Y', filter_glob="*.x3d", use_selection=False, use_mesh_modifiers=True, use_triangulate=False, use_normals=False, use_compress=False, use_hierarchy=True, name_decorations=True, use_h3d=False, global_scale=1, path_mode='AUTO')

# Automatically pack all external files into the .blend file
bpy.ops.file.autopack_toggle()
# Add a bookmark for the selected/active directory
bpy.ops.file.bookmark_add()
# Delete all invalid bookmarks
bpy.ops.file.bookmark_cleanup()
# Delete selected bookmark
bpy.ops.file.bookmark_delete(index=-1)
# Move the active bookmark up/down in the list
bpy.ops.file.bookmark_move(direction='TOP')
# Toggle bookmarks display
bpy.ops.file.bookmark_toggle()
# Cancel loading of selected file
bpy.ops.file.cancel()
# Delete selected files
bpy.ops.file.delete()
# Create a new directory
bpy.ops.file.directory_new(directory="", open=False)
# Execute selected file
bpy.ops.file.execute(need_active=False)
# Increment number in filename
bpy.ops.file.filenum(increment=1)
#
bpy.ops.file.filepath_drop(filepath="Path")
# Try to find missing external files
bpy.ops.file.find_missing_files(find_all=False, directory="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=False, filter_blenlib=False, filemode=9, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA')
# Toggle hide hidden dot files
bpy.ops.file.hidedot()
# Highlight selected file(s)
bpy.ops.file.highlight()
# Make all paths to external files absolute
bpy.ops.file.make_paths_absolute()
# Make all paths to external files relative to current .blend
bpy.ops.file.make_paths_relative()
# Move to next folder
bpy.ops.file.next()
# Pack all used external files into the .blend
bpy.ops.file.pack_all()
# Pack all used Blender library files into the current .blend
bpy.ops.file.pack_libraries()
# Move to parent directory
bpy.ops.file.parent()
# Move to previous folder
bpy.ops.file.previous()
# Refresh the file list
bpy.ops.file.refresh()
# Rename file or file directory
bpy.ops.file.rename()
# Report all missing external files
bpy.ops.file.report_missing_files()
# Reset Recent files
bpy.ops.file.reset_recent()
# Activate/select file
bpy.ops.file.select(extend=False, fill=False, open=True)
# Select or deselect all files
bpy.ops.file.select_all_toggle()
# Select a bookmarked directory
bpy.ops.file.select_bookmark(dir="")
# Activate/select the file(s) contained in the border
bpy.ops.file.select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
# Select/Deselect files by walking through them
bpy.ops.file.select_walk(direction='UP', extend=False, fill=False)
# Smooth scroll to make editable file visible
bpy.ops.file.smoothscroll()
# Unpack all files packed into this .blend to external ones
bpy.ops.file.unpack_all(method='USE_LOCAL')
# Unpack this file to an external file
bpy.ops.file.unpack_item(method='USE_LOCAL', id_name="", id_type=19785)
# Unpack all used Blender library files from this .blend file
bpy.ops.file.unpack_libraries()

# Bake fluid simulation
bpy.ops.fluid.bake()
# Add or remove a Fluid Preset
bpy.ops.fluid.preset_add(name="", remove_active=False)

# Set font case
bpy.ops.font.case_set(case='LOWER')
# Toggle font case
bpy.ops.font.case_toggle()
# Change font character code
bpy.ops.font.change_character(delta=1)
# Change font spacing
bpy.ops.font.change_spacing(delta=1)
# Delete text by cursor position
bpy.ops.font.delete(type='ALL')
# Insert line break at cursor position
bpy.ops.font.line_break()
# Move cursor to position type
bpy.ops.font.move(type='LINE_BEGIN')
# Move the cursor while selecting
bpy.ops.font.move_select(type='LINE_BEGIN')
# Load a new font from a file
bpy.ops.font.open(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=True, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, relative_path=True, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA')
# Select all text
bpy.ops.font.select_all()
# Set font style
bpy.ops.font.style_set(style='BOLD', clear=False)
# Toggle font style
bpy.ops.font.style_toggle(style='BOLD')
# Copy selected text to clipboard
bpy.ops.font.text_copy()
# Cut selected text to clipboard
bpy.ops.font.text_cut()
# Insert text at cursor position
bpy.ops.font.text_insert(text="", accent=False)
# Paste text from clipboard
bpy.ops.font.text_paste()
# Paste contents from file
bpy.ops.font.text_paste_from_file(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=True, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA')
# Add a new text box
bpy.ops.font.textbox_add()
# Remove the textbox
bpy.ops.font.textbox_remove(index=0)
# Unlink active font data-block
bpy.ops.font.unlink()

# Delete the active frame for the active Grease Pencil Layer
bpy.ops.gpencil.active_frame_delete()
# Delete the active frame(s) of all editable Grease Pencil layers
bpy.ops.gpencil.active_frames_delete_all()
# Insert a blank frame on the current frame (all subsequently existing frames, if any, are shifted right by one frame)
bpy.ops.gpencil.blank_frame_add(all_layers=False)
# Add new Grease Pencil drawing brush for the active Grease Pencil data-block
bpy.ops.gpencil.brush_add()
# Change active Grease Pencil drawing brush
bpy.ops.gpencil.brush_change(brush='<UNKNOWN ENUM>')
# Copy current Grease Pencil drawing brush
bpy.ops.gpencil.brush_copy()
# Move the active Grease Pencil drawing brush up/down in the list
bpy.ops.gpencil.brush_move(type='UP')
# Apply tweaks to strokes by painting over the strokes
bpy.ops.gpencil.brush_paint(stroke=[], wait_for_input=True)
# Create a set of predefined Grease Pencil drawing brushes
bpy.ops.gpencil.brush_presets_create()
# Remove active Grease Pencil drawing brush
bpy.ops.gpencil.brush_remove()
# Select a Grease Pencil drawing brush
bpy.ops.gpencil.brush_select(index=0)
# Convert the active Grease Pencil layer to a new Curve Object
bpy.ops.gpencil.convert(type='PATH', use_normalize_weights=True, radius_multiplier=1, use_link_strokes=True, timing_mode='<UNKNOWN ENUM>', frame_range=100, start_frame=1, use_realtime=False, end_frame=250, gap_duration=0, gap_randomness=0, seed=0, use_timing_data=False)
# Copy selected Grease Pencil points and strokes
bpy.ops.gpencil.copy()
# Add new Grease Pencil data-block
bpy.ops.gpencil.data_add()
# Unlink active Grease Pencil data-block
bpy.ops.gpencil.data_unlink()
# Delete selected Grease Pencil strokes, vertices, or frames
bpy.ops.gpencil.delete(type='POINTS')
# Delete selected points without splitting strokes
bpy.ops.gpencil.dissolve()
# Make annotations on the active data
bpy.ops.gpencil.draw(mode='DRAW', stroke=[], wait_for_input=True)
# Duplicate the selected Grease Pencil strokes
bpy.ops.gpencil.duplicate()
# Make copies of the selected Grease Pencil strokes and move them
bpy.ops.gpencil.duplicate_move(GPENCIL_OT_duplicate={}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Enter/Exit edit mode for Grease Pencil strokes
bpy.ops.gpencil.editmode_toggle()
# Hide selected/unselected Grease Pencil layers
bpy.ops.gpencil.hide(unselected=False)
# Interpolate grease pencil strokes between frames
bpy.ops.gpencil.interpolate(shift=0)
# Remove breakdown frames generated by interpolating between two Grease Pencil frames
bpy.ops.gpencil.interpolate_reverse()
# Generate 'in-betweens' to smoothly interpolate between Grease Pencil frames
bpy.ops.gpencil.interpolate_sequence()
# Add new Grease Pencil layer for the active Grease Pencil data-block
bpy.ops.gpencil.layer_add()
# Change active Grease Pencil layer
bpy.ops.gpencil.layer_change(layer='DEFAULT')
# Make a copy of the active Grease Pencil layer
bpy.ops.gpencil.layer_duplicate()
# Toggle whether the active layer is the only one that can be edited and/or visible
bpy.ops.gpencil.layer_isolate(affect_visibility=False)
# Merge the current layer with the layer below
bpy.ops.gpencil.layer_merge()
# Move the active Grease Pencil layer up/down in the list
bpy.ops.gpencil.layer_move(type='UP')
# Remove active Grease Pencil layer
bpy.ops.gpencil.layer_remove()
# Lock all Grease Pencil layers to prevent them from being accidentally modified
bpy.ops.gpencil.lock_all()
# Move selected strokes to another layer
bpy.ops.gpencil.move_to_layer(layer='DEFAULT')
# Add new Grease Pencil palette for the active Grease Pencil data-block
bpy.ops.gpencil.palette_add()
# Change active Grease Pencil palette
bpy.ops.gpencil.palette_change(palette='DEFAULT')
# Lock and hide any color not used in any layer
bpy.ops.gpencil.palette_lock_layer()
# Remove active Grease Pencil palette
bpy.ops.gpencil.palette_remove()
# Add new Grease Pencil palette color for the active Grease Pencil data-block
bpy.ops.gpencil.palettecolor_add()
# Copy current Grease Pencil palette color
bpy.ops.gpencil.palettecolor_copy()
# Hide selected/unselected Grease Pencil colors
bpy.ops.gpencil.palettecolor_hide(unselected=False)
# Toggle whether the active color is the only one that is editable and/or visible
bpy.ops.gpencil.palettecolor_isolate(affect_visibility=False)
# Lock all Grease Pencil colors to prevent them from being accidentally modified
bpy.ops.gpencil.palettecolor_lock_all()
# Move the active Grease Pencil palette color up/down in the list
bpy.ops.gpencil.palettecolor_move(direction='UP')
# Remove active Grease Pencil palette color
bpy.ops.gpencil.palettecolor_remove()
# Unhide all hidden Grease Pencil palette colors
bpy.ops.gpencil.palettecolor_reveal()
# Select all Grease Pencil strokes using current color
bpy.ops.gpencil.palettecolor_select()
# Unlock all Grease Pencil colors so that they can be edited
bpy.ops.gpencil.palettecolor_unlock_all()
# Paste previously copied strokes or copy and merge in active layer
bpy.ops.gpencil.paste(type='COPY')
# Reproject the selected strokes from the current viewpoint as if they had been newly drawn (e.g. to fix problems from accidental 3D cursor movement or accidental viewport changes, or for matching deforming geometry)
bpy.ops.gpencil.reproject(type='PLANAR')
# Show all Grease Pencil layers
bpy.ops.gpencil.reveal()
# Select Grease Pencil strokes and/or stroke points
bpy.ops.gpencil.select(extend=False, deselect=False, toggle=False, entire_strokes=False, location=(0, 0))
# Change selection of all Grease Pencil strokes currently visible
bpy.ops.gpencil.select_all(action='TOGGLE')
# Select Grease Pencil strokes within a rectangular region
bpy.ops.gpencil.select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
# Select Grease Pencil strokes using brush selection
bpy.ops.gpencil.select_circle(x=0, y=0, radius=1, gesture_mode=0)
# Select first point in Grease Pencil strokes
bpy.ops.gpencil.select_first(only_selected_strokes=False, extend=False)
# Select all strokes with similar characteristics
bpy.ops.gpencil.select_grouped(type='LAYER')
# Select Grease Pencil strokes using lasso selection
bpy.ops.gpencil.select_lasso(path=[], deselect=False, extend=True)
# Select last point in Grease Pencil strokes
bpy.ops.gpencil.select_last(only_selected_strokes=False, extend=False)
# Shrink sets of selected Grease Pencil points
bpy.ops.gpencil.select_less()
# Select all points in same strokes as already selected points
bpy.ops.gpencil.select_linked()
# Grow sets of selected Grease Pencil points
bpy.ops.gpencil.select_more()
# Hide/Unhide selected points for Grease Pencil strokes setting alpha factor
bpy.ops.gpencil.selection_opacity_toggle()
# Snap cursor to center of selected points
bpy.ops.gpencil.snap_cursor_to_selected()
# Snap selected points/strokes to the cursor
bpy.ops.gpencil.snap_to_cursor(use_offset=True)
# Snap selected points to the nearest grid points
bpy.ops.gpencil.snap_to_grid()
# Apply the thickness change of the layer to its strokes
bpy.ops.gpencil.stroke_apply_thickness()
# Arrange selected strokes up/down in the drawing order of the active layer
bpy.ops.gpencil.stroke_arrange(direction='UP')
# Move selected strokes to active color
bpy.ops.gpencil.stroke_change_color()
# Close or open the selected stroke adding an edge from last to first point
bpy.ops.gpencil.stroke_cyclical_set(type='TOGGLE')
# Change direction of the points of the selected strokes
bpy.ops.gpencil.stroke_flip()
# Join selected strokes (optionally as new stroke)
bpy.ops.gpencil.stroke_join(type='JOIN', leave_gaps=False)
# Lock any color not used in any selected stroke
bpy.ops.gpencil.stroke_lock_color()
# Subdivide between continuous selected points of the stroke adding a point half way between them
bpy.ops.gpencil.stroke_subdivide(number_cuts=1)
# Unlock all Grease Pencil layers so that they can be edited
bpy.ops.gpencil.unlock_all()

# Bake selected F-Curves to a set of sampled points defining a similar curve
bpy.ops.graph.bake()
# Simplify F-Curves by removing closely spaced keyframes
bpy.ops.graph.clean(threshold=0.001, channels=False)
# Insert new keyframe at the cursor position for the active F-Curve
bpy.ops.graph.click_insert(frame=1, value=1, extend=False)
# Select keyframes by clicking on them
bpy.ops.graph.clickselect(extend=False, column=False, curves=False)
# Copy selected keyframes to the copy/paste buffer
bpy.ops.graph.copy()
# Interactively set the current frame and value cursor
bpy.ops.graph.cursor_set(frame=0, value=0)
# Remove all selected keyframes
bpy.ops.graph.delete()
# Copy the driver variables of the active F-Curve
bpy.ops.graph.driver_variables_copy()
# Add copied driver variables to the active driver
bpy.ops.graph.driver_variables_paste(replace=False)
# Make a copy of all selected keyframes
bpy.ops.graph.duplicate(mode='TRANSLATION')
# Make a copy of all selected keyframes and move them
bpy.ops.graph.duplicate_move(GRAPH_OT_duplicate={"mode":'TRANSLATION'}, TRANSFORM_OT_transform={"mode":'TRANSLATION', "value":(0, 0, 0, 0), "axis":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "release_confirm":False, "use_accurate":False})
# Set easing type for the F-Curve segments starting from the selected keyframes
bpy.ops.graph.easing_type(type='AUTO')
# Fix large jumps and flips in the selected Euler Rotation F-Curves arising from rotation values being clipped when baking physics
bpy.ops.graph.euler_filter()
# Set extrapolation mode for selected F-Curves
bpy.ops.graph.extrapolation_type(type='CONSTANT')
# Add F-Modifier to the active/selected F-Curves
bpy.ops.graph.fmodifier_add(type='NULL', only_active=True)
# Copy the F-Modifier(s) of the active F-Curve
bpy.ops.graph.fmodifier_copy()
# Add copied F-Modifiers to the selected F-Curves
bpy.ops.graph.fmodifier_paste(only_active=True, replace=False)
# Place the cursor on the midpoint of selected keyframes
bpy.ops.graph.frame_jump()
# Clear F-Curve snapshots (Ghosts) for active Graph Editor
bpy.ops.graph.ghost_curves_clear()
# Create snapshot (Ghosts) of selected F-Curves as background aid for active Graph Editor
bpy.ops.graph.ghost_curves_create()
# Set type of handle for selected keyframes
bpy.ops.graph.handle_type(type='FREE')
# Hide selected curves from Graph Editor view
bpy.ops.graph.hide(unselected=False)
# Set interpolation mode for the F-Curve segments starting from the selected keyframes
bpy.ops.graph.interpolation_type(type='CONSTANT')
# Insert keyframes for the specified channels
bpy.ops.graph.keyframe_insert(type='ALL')
# Flip selected keyframes over the selected mirror line
bpy.ops.graph.mirror(type='CFRA')
# Paste keyframes from copy/paste buffer for the selected channels, starting on the current frame
bpy.ops.graph.paste(offset='START', merge='MIX', flipped=False)
# Automatically set Preview Range based on range of keyframes
bpy.ops.graph.previewrange_set()
# Toggle the properties region visibility
bpy.ops.graph.properties()
# Make previously hidden curves visible again in Graph Editor view
bpy.ops.graph.reveal()
# Add keyframes on every frame between the selected keyframes
bpy.ops.graph.sample()
# Toggle selection of all keyframes
bpy.ops.graph.select_all_toggle(invert=False)
# Select all keyframes within the specified region
bpy.ops.graph.select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True, axis_range=False, include_handles=False)
# Select keyframe points using circle selection
bpy.ops.graph.select_circle(x=0, y=0, radius=1, gesture_mode=0)
# Select all keyframes on the specified frame(s)
bpy.ops.graph.select_column(mode='KEYS')
# Select keyframe points using lasso selection
bpy.ops.graph.select_lasso(path=[], deselect=False, extend=True)
# Select keyframes to the left or the right of the current frame
bpy.ops.graph.select_leftright(mode='CHECK', extend=False)
# Deselect keyframes on ends of selection islands
bpy.ops.graph.select_less()
# Select keyframes occurring in the same F-Curves as selected ones
bpy.ops.graph.select_linked()
# Select keyframes beside already selected ones
bpy.ops.graph.select_more()
# Apply weighted moving means to make selected F-Curves less bumpy
bpy.ops.graph.smooth()
# Snap selected keyframes to the chosen times/values
bpy.ops.graph.snap(type='CFRA')
# Bakes a sound wave to selected F-Curves
bpy.ops.graph.sound_bake(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=True, filter_python=False, filter_font=False, filter_sound=True, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, show_multiview=False, use_multiview=False, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', low=0, high=100000, attack=0.005, release=0.2, threshold=0, use_accumulate=False, use_additive=False, use_square=False, sthreshold=0.1)
# Reset viewable area to show full keyframe range
bpy.ops.graph.view_all(include_handles=True)
# Reset viewable area to show range around current frame
bpy.ops.graph.view_frame()
# Reset viewable area to show selected keyframe range
bpy.ops.graph.view_selected(include_handles=True)

# Create an object group from selected objects
bpy.ops.group.create(name="Group")
# Add the object to an object group that contains the active object
bpy.ops.group.objects_add_active(group='<UNKNOWN ENUM>')
# Remove selected objects from a group
bpy.ops.group.objects_remove(group='<UNKNOWN ENUM>')
# Remove the object from an object group that contains the active object
bpy.ops.group.objects_remove_active(group='<UNKNOWN ENUM>')
# Remove selected objects from all groups
bpy.ops.group.objects_remove_all()

# Interactively change the current frame number
bpy.ops.image.change_frame(frame=0)
# Clear the boundaries of the border render and disable border render
bpy.ops.image.clear_render_border()
# Set black point or white point for curves
bpy.ops.image.curves_point_set(point='BLACK_POINT')
# Cycle through all non-void render slots
bpy.ops.image.cycle_render_slot(reverse=False)
# Edit image in an external application
bpy.ops.image.external_edit(filepath="")
# Invert image's channels
bpy.ops.image.invert(invert_r=False, invert_g=False, invert_b=False, invert_a=False)
# Set image's user's length to the one of this video
bpy.ops.image.match_movie_length()
# Create a new image
bpy.ops.image.new(name="Untitled", width=1024, height=1024, color=(0, 0, 0, 1), alpha=True, generated_type='BLANK', float=False, gen_context='NONE', use_stereo_3d=False)
# Open image
bpy.ops.image.open(filepath="", directory="", files=[], filter_blender=False, filter_backup=False, filter_image=True, filter_movie=True, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, relative_path=True, show_multiview=False, use_multiview=False, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', use_sequence_detection=True)
# Pack an image as embedded data into the .blend file
bpy.ops.image.pack(as_png=False)
# Project edited image back onto the object
bpy.ops.image.project_apply()
# Edit a snapshot of the view-port in an external image editor
bpy.ops.image.project_edit()
# Toggle the properties region visibility
bpy.ops.image.properties()
# Read all the current scene's render layers from cache, as needed
bpy.ops.image.read_renderlayers()
# Reload current image from disk
bpy.ops.image.reload()
# Set the boundaries of the border render and enable border render
bpy.ops.image.render_border(xmin=0, xmax=0, ymin=0, ymax=0)
# Replace current image by another one from disk
bpy.ops.image.replace(filepath="", filter_blender=False, filter_backup=False, filter_image=True, filter_movie=True, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, relative_path=True, show_multiview=False, use_multiview=False, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA')
# Use mouse to sample a color in current image
bpy.ops.image.sample()
# Sample a line and show it in Scope panels
bpy.ops.image.sample_line(xstart=0, xend=0, ystart=0, yend=0, cursor=1002)
# Save the image with current name and settings
bpy.ops.image.save()
# Save the image with another name and/or settings
bpy.ops.image.save_as(save_as_render=False, copy=False, filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=True, filter_movie=True, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, relative_path=True, show_multiview=False, use_multiview=False, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA')
# Save all modified textures
bpy.ops.image.save_dirty()
# Save a sequence of images
bpy.ops.image.save_sequence()
# Toggles tool shelf display
bpy.ops.image.toolshelf()
# Save an image packed in the .blend file to disk
bpy.ops.image.unpack(method='USE_LOCAL', id="")
# View the entire image
bpy.ops.image.view_all(fit_view=False)
# Use a 3D mouse device to pan/zoom the view
bpy.ops.image.view_ndof()
# Pan the view
bpy.ops.image.view_pan(offset=(0, 0))
# View all selected UVs
bpy.ops.image.view_selected()
# Zoom in/out the image
bpy.ops.image.view_zoom(factor=0)
# Zoom in the view to the nearest item contained in the border
bpy.ops.image.view_zoom_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0)
# Zoom in the image (centered around 2D cursor)
bpy.ops.image.view_zoom_in(location=(0, 0))
# Zoom out the image (centered around 2D cursor)
bpy.ops.image.view_zoom_out(location=(0, 0))
# Set zoom ratio of the view
bpy.ops.image.view_zoom_ratio(ratio=0)

# Load a BVH motion capture file
bpy.ops.import_anim.bvh(filepath="", axis_forward='-Z', axis_up='Y', filter_glob="*.bvh", target='ARMATURE', global_scale=1, frame_start=1, use_fps_scale=False, update_scene_fps=False, update_scene_duration=False, use_cyclic=False, rotate_mode='NATIVE')

# Load a SVG file
bpy.ops.import_curve.svg(filepath="", filter_glob="*.svg")

# Load a PLY geometry file
bpy.ops.import_mesh.ply(filepath="", files=[], directory="", filter_glob="*.ply")
# Load STL triangle mesh data
bpy.ops.import_mesh.stl(filepath="", axis_forward='Y', axis_up='Z', filter_glob="*.stl", files=[], directory="", global_scale=1, use_scene_unit=False, use_facet_normal=False)

# Import from 3DS file format (.3ds)
bpy.ops.import_scene.autodesk_3ds(filepath="", axis_forward='Y', axis_up='Z', filter_glob="*.3ds", constrain_size=10, use_image_search=True, use_apply_transform=True)
# Load a FBX file
bpy.ops.import_scene.fbx(filepath="", axis_forward='-Z', axis_up='Y', directory="", filter_glob="*.fbx", ui_tab='MAIN', use_manual_orientation=False, global_scale=1, bake_space_transform=False, use_custom_normals=True, use_image_search=True, use_alpha_decals=False, decal_offset=0, use_anim=True, anim_offset=1, use_custom_props=True, use_custom_props_enum_as_string=True, ignore_leaf_bones=False, force_connect_children=False, automatic_bone_orientation=False, primary_bone_axis='Y', secondary_bone_axis='X', use_prepost_rot=True)
# Load a Wavefront OBJ File
bpy.ops.import_scene.obj(filepath="", axis_forward='-Z', axis_up='Y', filter_glob="*.obj;*.mtl", use_edges=True, use_smooth_groups=True, use_split_objects=True, use_split_groups=True, use_groups_as_vgroups=False, use_image_search=True, split_mode='ON', global_clamp_size=0)
# Import an X3D or VRML2 file
bpy.ops.import_scene.x3d(filepath="", axis_forward='Z', axis_up='Y', filter_glob="*.x3d;*.wrl")

# Copy selected reports to Clipboard
bpy.ops.info.report_copy()
# Delete selected reports
bpy.ops.info.report_delete()
# Replay selected reports
bpy.ops.info.report_replay()
# Update the display of reports in Blender UI (internal use)
bpy.ops.info.reports_display_update()
# Select or deselect all reports
bpy.ops.info.select_all_toggle()
# Toggle border selection
bpy.ops.info.select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
# Select reports by index
bpy.ops.info.select_pick(report_index=0)

# Add or remove a Sky & Atmosphere Preset
bpy.ops.lamp.sunsky_preset_add(name="", remove_active=False)

# Mirror all control points without inverting the lattice deform
bpy.ops.lattice.flip(axis='U')
# Set UVW control points a uniform distance apart
bpy.ops.lattice.make_regular()
# Change selection of all UVW control points
bpy.ops.lattice.select_all(action='TOGGLE')
# Deselect vertices at the boundary of each selection region
bpy.ops.lattice.select_less()
# Select mirrored lattice points
bpy.ops.lattice.select_mirror(axis={'X'}, extend=False)
# Select vertex directly linked to already selected ones
bpy.ops.lattice.select_more()
# Randomly select UVW control points
bpy.ops.lattice.select_random(percent=50, seed=0, action='SELECT')
# Select vertices without a group
bpy.ops.lattice.select_ungrouped(extend=False)

# Add an actuator to the active object
bpy.ops.logic.actuator_add(type='MOTION', name="", object="")
# Move Actuator
bpy.ops.logic.actuator_move(actuator="", object="", direction='UP')
# Remove an actuator from the active object
bpy.ops.logic.actuator_remove(actuator="", object="")
# Add a controller to the active object
bpy.ops.logic.controller_add(type='LOGIC_AND', name="", object="")
# Move Controller
bpy.ops.logic.controller_move(controller="", object="", direction='UP')
# Remove a controller from the active object
bpy.ops.logic.controller_remove(controller="", object="")
# Remove logic brick connections
bpy.ops.logic.links_cut(path=[], cursor=9)
# Toggle the properties region visibility
bpy.ops.logic.properties()
# Add a sensor to the active object
bpy.ops.logic.sensor_add(type='ALWAYS', name="", object="")
# Move Sensor
bpy.ops.logic.sensor_move(sensor="", object="", direction='UP')
# Remove a sensor from the active object
bpy.ops.logic.sensor_remove(sensor="", object="")
# Resize view so you can see all logic bricks
bpy.ops.logic.view_all()

# Add a new time marker
bpy.ops.marker.add()
# Bind the active camera to selected marker(s)
bpy.ops.marker.camera_bind()
# Delete selected time marker(s)
bpy.ops.marker.delete()
# Duplicate selected time marker(s)
bpy.ops.marker.duplicate(frames=0)
# Copy selected markers to another scene
bpy.ops.marker.make_links_scene(scene='Scene')
# Move selected time marker(s)
bpy.ops.marker.move(frames=0)
# Rename first selected time marker
bpy.ops.marker.rename(name="RenamedMarker")
# Select time marker(s)
bpy.ops.marker.select(extend=False, camera=False)
# Change selection of all time markers
bpy.ops.marker.select_all(action='TOGGLE')
# Select all time markers using border selection
bpy.ops.marker.select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)

# Add vertex to feather
bpy.ops.mask.add_feather_vertex(location=(0, 0))
# Add new vertex to feather and slide it
bpy.ops.mask.add_feather_vertex_slide(MASK_OT_add_feather_vertex={"location":(0, 0)}, MASK_OT_slide_point={"slide_feather":False, "is_new_point":False})
# Add vertex to active spline
bpy.ops.mask.add_vertex(location=(0, 0))
# Add new vertex and slide it
bpy.ops.mask.add_vertex_slide(MASK_OT_add_vertex={"location":(0, 0)}, MASK_OT_slide_point={"slide_feather":False, "is_new_point":False})
# Copy selected splines to clipboard
bpy.ops.mask.copy_splines()
# Toggle cyclic for selected splines
bpy.ops.mask.cyclic_toggle()
# Delete selected control points or splines
bpy.ops.mask.delete()
# Duplicate selected control points and segments between them
bpy.ops.mask.duplicate()
# Duplicate mask and move
bpy.ops.mask.duplicate_move(MASK_OT_duplicate={}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Reset the feather weight to zero
bpy.ops.mask.feather_weight_clear()
# Set type of handles for selected control points
bpy.ops.mask.handle_type_set(type='AUTO')
# Reveal the layer by setting the hide flag
bpy.ops.mask.hide_view_clear()
# Hide the layer by setting the hide flag
bpy.ops.mask.hide_view_set(unselected=False)
# Move the active layer up/down in the list
bpy.ops.mask.layer_move(direction='UP')
# Add new mask layer for masking
bpy.ops.mask.layer_new(name="")
# Remove mask layer
bpy.ops.mask.layer_remove()
# Create new mask
bpy.ops.mask.new(name="")
# Re-calculate the direction of selected handles
bpy.ops.mask.normals_make_consistent()
# Clear the mask's parenting
bpy.ops.mask.parent_clear()
# Set the mask's parenting
bpy.ops.mask.parent_set()
# Paste splines from clipboard
bpy.ops.mask.paste_splines()
# Add new circle-shaped spline
bpy.ops.mask.primitive_circle_add(size=100, location=(0, 0))
# Add new square-shaped spline
bpy.ops.mask.primitive_square_add(size=100, location=(0, 0))
# Select spline points
bpy.ops.mask.select(extend=False, deselect=False, toggle=False, location=(0, 0))
# Change selection of all curve points
bpy.ops.mask.select_all(action='TOGGLE')
# Select curve points using border selection
bpy.ops.mask.select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
# Select curve points using circle selection
bpy.ops.mask.select_circle(x=0, y=0, radius=1, gesture_mode=0)
# Select curve points using lasso selection
bpy.ops.mask.select_lasso(path=[], deselect=False, extend=True)
# Deselect spline points at the boundary of each selection region
bpy.ops.mask.select_less()
# Select all curve points linked to already selected ones
bpy.ops.mask.select_linked()
# (De)select all points linked to the curve under the mouse cursor
bpy.ops.mask.select_linked_pick(deselect=False)
# Select more spline points connected to initial selection
bpy.ops.mask.select_more()
#
bpy.ops.mask.shape_key_clear()
# Reset feather weights on all selected points animation values
bpy.ops.mask.shape_key_feather_reset()
#
bpy.ops.mask.shape_key_insert()
# Recalculate animation data on selected points for frames selected in the dopesheet
bpy.ops.mask.shape_key_rekey(location=True, feather=True)
# Slide control points
bpy.ops.mask.slide_point(slide_feather=False, is_new_point=False)
# Slide a point on the spline to define it's curvature
bpy.ops.mask.slide_spline_curvature()
# Switch direction of selected splines
bpy.ops.mask.switch_direction()

# Copy the material settings and nodes
bpy.ops.material.copy()
# Add a new material
bpy.ops.material.new()
# Paste the material settings and nodes
bpy.ops.material.paste()
# Add or remove a Subsurface Scattering Preset
bpy.ops.material.sss_preset_add(name="", remove_active=False)

# Delete selected metaelement(s)
bpy.ops.mball.delete_metaelems()
# Duplicate selected metaelement(s)
bpy.ops.mball.duplicate_metaelems()
# Make copies of the selected metaelements and move them
bpy.ops.mball.duplicate_move(MBALL_OT_duplicate_metaelems={}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Hide (un)selected metaelement(s)
bpy.ops.mball.hide_metaelems(unselected=False)
# Reveal all hidden metaelements
bpy.ops.mball.reveal_metaelems()
# Change selection of all meta elements
bpy.ops.mball.select_all(action='TOGGLE')
# Randomly select metaelements
bpy.ops.mball.select_random_metaelems(percent=50, seed=0, action='SELECT')
# Select similar metaballs by property types
bpy.ops.mball.select_similar(type='TYPE', threshold=0.1)

# Rearrange some faces to try to get less degenerated geometry
bpy.ops.mesh.beautify_fill(angle_limit=3.14159)
# Edge Bevel
bpy.ops.mesh.bevel(offset_type='OFFSET', offset=0, segments=1, profile=0.5, vertex_only=False, clamp_overlap=False, loop_slide=True, material=-1)
# Cut geometry along a plane (click-drag to define plane)
bpy.ops.mesh.bisect(plane_co=(0, 0, 0), plane_no=(0, 0, 0), use_fill=False, clear_inner=False, clear_outer=False, threshold=0.0001, xstart=0, xend=0, ystart=0, yend=0, cursor=1002)
# Blend in shape from a shape key
bpy.ops.mesh.blend_from_shape(shape='<UNKNOWN ENUM>', blend=1, add=True)
# Make faces between two or more edge loops
bpy.ops.mesh.bridge_edge_loops(type='SINGLE', use_merge=False, merge_factor=0.5, twist_offset=0, number_cuts=0, interpolation='PATH', smoothness=1, profile_shape_factor=0, profile_shape='SMOOTH')
# Flip direction of vertex colors inside faces
bpy.ops.mesh.colors_reverse()
# Rotate vertex colors inside faces
bpy.ops.mesh.colors_rotate(use_ccw=False)
# Enclose selected vertices in a convex polyhedron
bpy.ops.mesh.convex_hull(delete_unused=True, use_existing_faces=True, make_holes=False, join_triangles=True, face_threshold=0.698132, shape_threshold=0.698132, uvs=False, vcols=False, seam=False, sharp=False, materials=False)
# Add a custom split normals layer, if none exists yet
bpy.ops.mesh.customdata_custom_splitnormals_add()
# Remove the custom split normals layer, if it exists
bpy.ops.mesh.customdata_custom_splitnormals_clear()
# Clear vertex sculpt masking data from the mesh
bpy.ops.mesh.customdata_mask_clear()
# Add a vertex skin layer
bpy.ops.mesh.customdata_skin_add()
# Clear vertex skin layer
bpy.ops.mesh.customdata_skin_clear()
# Simplify geometry by collapsing edges
bpy.ops.mesh.decimate(ratio=1, use_vertex_group=False, vertex_group_factor=1, invert_vertex_group=False, use_symmetry=False, symmetry_axis='Y')
# Delete selected vertices, edges or faces
bpy.ops.mesh.delete(type='VERT')
# Delete an edge loop by merging the faces on each side
bpy.ops.mesh.delete_edgeloop(use_face_split=True)
# Delete loose vertices, edges or faces
bpy.ops.mesh.delete_loose(use_verts=True, use_edges=True, use_faces=False)
# Dissolve zero area faces and zero length edges
bpy.ops.mesh.dissolve_degenerate(threshold=0.0001)
# Dissolve edges, merging faces
bpy.ops.mesh.dissolve_edges(use_verts=True, use_face_split=False)
# Dissolve faces
bpy.ops.mesh.dissolve_faces(use_verts=False)
# Dissolve selected edges and verts, limited by the angle of surrounding geometry
bpy.ops.mesh.dissolve_limited(angle_limit=0.0872665, use_dissolve_boundaries=False, delimit={'NORMAL'})
# Dissolve geometry based on the selection mode
bpy.ops.mesh.dissolve_mode(use_verts=False, use_face_split=False, use_boundary_tear=False)
# Dissolve verts, merge edges and faces
bpy.ops.mesh.dissolve_verts(use_face_split=False, use_boundary_tear=False)
# Assign Image to active UV Map, or create an UV Map
bpy.ops.mesh.drop_named_image(name="Image", filepath="Path", relative_path=True)
# Duplicate and extrude selected vertices, edges or faces towards the mouse cursor
bpy.ops.mesh.dupli_extrude_cursor(rotate_source=True)
# Duplicate selected vertices, edges or faces
bpy.ops.mesh.duplicate(mode=1)
# Duplicate mesh and move
bpy.ops.mesh.duplicate_move(MESH_OT_duplicate={"mode":1}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Collapse selected edges
bpy.ops.mesh.edge_collapse()
# Add an edge or face to selected
bpy.ops.mesh.edge_face_add()
# Rotate selected edge or adjoining faces
bpy.ops.mesh.edge_rotate(use_ccw=False)
# Split selected edges so that each neighbor face gets its own copy
bpy.ops.mesh.edge_split()
# Select an edge ring
bpy.ops.mesh.edgering_select(extend=False, deselect=False, toggle=False, ring=True)
# Select all sharp-enough edges
bpy.ops.mesh.edges_select_sharp(sharpness=0.523599)
# Extrude individual edges only
bpy.ops.mesh.extrude_edges_indiv(mirror=False)
# Extrude edges and move result
bpy.ops.mesh.extrude_edges_move(MESH_OT_extrude_edges_indiv={"mirror":False}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Extrude individual faces only
bpy.ops.mesh.extrude_faces_indiv(mirror=False)
# Extrude faces and move result
bpy.ops.mesh.extrude_faces_move(MESH_OT_extrude_faces_indiv={"mirror":False}, TRANSFORM_OT_shrink_fatten={"value":0, "use_even_offset":True, "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "release_confirm":False, "use_accurate":False})
# Extrude region of faces
bpy.ops.mesh.extrude_region(mirror=False)
# Extrude region and move result
bpy.ops.mesh.extrude_region_move(MESH_OT_extrude_region={"mirror":False}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Extrude region and move result
bpy.ops.mesh.extrude_region_shrink_fatten(MESH_OT_extrude_region={"mirror":False}, TRANSFORM_OT_shrink_fatten={"value":0, "use_even_offset":True, "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "release_confirm":False, "use_accurate":False})
# Extrude selected vertices, edges or faces repeatedly
bpy.ops.mesh.extrude_repeat(offset=2, steps=10)
# Extrude vertices and move result
bpy.ops.mesh.extrude_vertices_move(MESH_OT_extrude_verts_indiv={"mirror":False}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Extrude individual vertices only
bpy.ops.mesh.extrude_verts_indiv(mirror=False)
# Flatten selected faces
bpy.ops.mesh.face_make_planar(factor=1, repeat=1)
# Weld loose edges into faces (splitting them into new faces)
bpy.ops.mesh.face_split_by_edges()
# Copy mirror UV coordinates on the X axis based on a mirrored mesh
bpy.ops.mesh.faces_mirror_uv(direction='POSITIVE', precision=3)
# Select linked faces by angle
bpy.ops.mesh.faces_select_linked_flat(sharpness=0.0174533)
# Display faces flat
bpy.ops.mesh.faces_shade_flat()
# Display faces smooth (using vertex normals)
bpy.ops.mesh.faces_shade_smooth()
# Fill a selected edge loop with faces
bpy.ops.mesh.fill(use_beauty=True)
# Fill grid from two loops
bpy.ops.mesh.fill_grid(span=1, offset=0, use_interp_simple=False)
# Fill in holes (boundary edge loops)
bpy.ops.mesh.fill_holes(sides=4)
# Flip the direction of selected faces' normals (and of their vertices)
bpy.ops.mesh.flip_normals()
# Hide (un)selected vertices, edges or faces
bpy.ops.mesh.hide(unselected=False)
# Inset new faces into selected faces
bpy.ops.mesh.inset(use_boundary=True, use_even_offset=True, use_relative_offset=False, use_edge_rail=False, thickness=0.01, depth=0, use_outset=False, use_select_inset=False, use_individual=False, use_interpolate=True)
# Cut an intersection into faces
bpy.ops.mesh.intersect(mode='SELECT_UNSELECT', separate_mode='CUT', threshold=1e-006)
# Cut solid geometry from selected to unselected
bpy.ops.mesh.intersect_boolean(operation='DIFFERENCE', use_swap=False, threshold=1e-006)
# Use other objects outlines & boundaries to project knife cuts
bpy.ops.mesh.knife_project(cut_through=False)
# Cut new topology
bpy.ops.mesh.knife_tool(use_occlude_geometry=True, only_selected=False)
# Select a loop of connected edges by connection type
bpy.ops.mesh.loop_multi_select(ring=False)
# Select a loop of connected edges
bpy.ops.mesh.loop_select(extend=False, deselect=False, toggle=False, ring=False)
# Select region of faces inside of a selected loop of edges
bpy.ops.mesh.loop_to_region(select_bigger=False)
# Add a new loop between existing loops
bpy.ops.mesh.loopcut(number_cuts=1, smoothness=0, falloff='INVERSE_SQUARE', edge_index=-1, mesh_select_mode_init=(False, False, False))
# Cut mesh loop and slide it
bpy.ops.mesh.loopcut_slide(MESH_OT_loopcut={"number_cuts":1, "smoothness":0, "falloff":'INVERSE_SQUARE', "edge_index":-1, "mesh_select_mode_init":(False, False, False)}, TRANSFORM_OT_edge_slide={"value":0, "single_side":False, "use_even":False, "flipped":False, "use_clamp":True, "mirror":False, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "correct_uv":False, "release_confirm":False, "use_accurate":False})
# (Un)mark selected edges as Freestyle feature edges
bpy.ops.mesh.mark_freestyle_edge(clear=False)
# (Un)mark selected faces for exclusion from Freestyle feature edge detection
bpy.ops.mesh.mark_freestyle_face(clear=False)
# (Un)mark selected edges as a seam
bpy.ops.mesh.mark_seam(clear=False)
# (Un)mark selected edges as sharp
bpy.ops.mesh.mark_sharp(clear=False, use_verts=False)
# Merge selected vertices
bpy.ops.mesh.merge(type='CENTER', uvs=False)
# Remove navmesh data from this mesh
bpy.ops.mesh.navmesh_clear()
# Add a new index and assign it to selected faces
bpy.ops.mesh.navmesh_face_add()
# Copy the index from the active face
bpy.ops.mesh.navmesh_face_copy()
# Create navigation mesh for selected objects
bpy.ops.mesh.navmesh_make()
# Assign a new index to every face
bpy.ops.mesh.navmesh_reset()
# Use vertex coordinate as texture coordinate
bpy.ops.mesh.noise(factor=0.1)
# Make face and vertex normals point either outside or inside the mesh
bpy.ops.mesh.normals_make_consistent(inside=False)
# Create offset edge loop from the current selection
bpy.ops.mesh.offset_edge_loops(use_cap_endpoint=False)
# Offset edge loop slide
bpy.ops.mesh.offset_edge_loops_slide(MESH_OT_offset_edge_loops={"use_cap_endpoint":False}, TRANSFORM_OT_edge_slide={"value":0, "single_side":False, "use_even":False, "flipped":False, "use_clamp":True, "mirror":False, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "correct_uv":False, "release_confirm":False, "use_accurate":False})
# Split a face into a fan
bpy.ops.mesh.poke(offset=0, use_relative_offset=False, center_mode='MEAN_WEIGHTED')
# Construct a circle mesh
bpy.ops.mesh.primitive_circle_add(vertices=32, radius=1, fill_type='NOTHING', calc_uvs=False, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Construct a conic mesh
bpy.ops.mesh.primitive_cone_add(vertices=32, radius1=1, radius2=0, depth=2, end_fill_type='NGON', calc_uvs=False, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Construct a cube mesh
bpy.ops.mesh.primitive_cube_add(radius=1, calc_uvs=False, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Construct a cylinder mesh
bpy.ops.mesh.primitive_cylinder_add(vertices=32, radius=1, depth=2, end_fill_type='NGON', calc_uvs=False, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Construct a grid mesh
bpy.ops.mesh.primitive_grid_add(x_subdivisions=10, y_subdivisions=10, radius=1, calc_uvs=False, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Construct an Icosphere mesh
bpy.ops.mesh.primitive_ico_sphere_add(subdivisions=2, size=1, calc_uvs=False, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Construct a Suzanne mesh
bpy.ops.mesh.primitive_monkey_add(radius=1, calc_uvs=False, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Construct a filled planar mesh with 4 vertices
bpy.ops.mesh.primitive_plane_add(radius=1, calc_uvs=False, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Add a torus mesh
bpy.ops.mesh.primitive_torus_add(view_align=False, rotation=(0, 0, 0), location=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False), major_segments=48, minor_segments=12, mode='MAJOR_MINOR', major_radius=1, minor_radius=0.25, abso_major_rad=1.25, abso_minor_rad=0.75, generate_uvs=False)
# Construct a UV sphere mesh
bpy.ops.mesh.primitive_uv_sphere_add(segments=32, ring_count=16, size=1, calc_uvs=False, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Triangulate selected faces
bpy.ops.mesh.quads_convert_to_tris(quad_method='BEAUTY', ngon_method='BEAUTY')
# Select boundary edges around the selected faces
bpy.ops.mesh.region_to_loop()
# Remove duplicate vertices
bpy.ops.mesh.remove_doubles(threshold=0.0001, use_unselected=False)
# Reveal all hidden vertices, edges and faces
bpy.ops.mesh.reveal()
# Disconnect vertex or edges from connected geometry
bpy.ops.mesh.rip(mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, release_confirm=False, use_accurate=False, use_fill=False)
# Extend vertices along the edge closest to the cursor
bpy.ops.mesh.rip_edge(mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, release_confirm=False, use_accurate=False)
# Extend vertices and move the result
bpy.ops.mesh.rip_edge_move(MESH_OT_rip_edge={"mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "release_confirm":False, "use_accurate":False}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Rip polygons and move the result
bpy.ops.mesh.rip_move(MESH_OT_rip={"mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "release_confirm":False, "use_accurate":False, "use_fill":False}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Rip-fill polygons and move the result
bpy.ops.mesh.rip_move_fill(MESH_OT_rip={"mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "release_confirm":False, "use_accurate":False, "use_fill":False}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Extrude selected vertices in screw-shaped rotation around the cursor in indicated viewport
bpy.ops.mesh.screw(steps=9, turns=1, center=(0, 0, 0), axis=(0, 0, 0))
# (De)select all vertices, edges or faces
bpy.ops.mesh.select_all(action='TOGGLE')
# Select all data in the mesh on a single axis
bpy.ops.mesh.select_axis(mode='POSITIVE', axis='X_AXIS', threshold=0.0001)
# Select vertices or faces by the number of polygon sides
bpy.ops.mesh.select_face_by_sides(number=4, type='EQUAL', extend=True)
# Select faces where all edges have more than 2 face users
bpy.ops.mesh.select_interior_faces()
# Deselect vertices, edges or faces at the boundary of each selection region
bpy.ops.mesh.select_less(use_face_step=True)
# Select all vertices connected to the current selection
bpy.ops.mesh.select_linked(delimit={'SEAM'})
# (De)select all vertices linked to the edge under the mouse cursor
bpy.ops.mesh.select_linked_pick(deselect=False, delimit={'SEAM'}, index=-1)
# Select loose geometry based on the selection mode
bpy.ops.mesh.select_loose(extend=False)
# Select mesh items at mirrored locations
bpy.ops.mesh.select_mirror(axis={'X'}, extend=False)
# Change selection mode
bpy.ops.mesh.select_mode(use_extend=False, use_expand=False, type='VERT', action='TOGGLE')
# Select more vertices, edges or faces connected to initial selection
bpy.ops.mesh.select_more(use_face_step=True)
# Select the next element (using selection order)
bpy.ops.mesh.select_next_item()
# Select all non-manifold vertices or edges
bpy.ops.mesh.select_non_manifold(extend=True, use_wire=True, use_boundary=True, use_multi_face=True, use_non_contiguous=True, use_verts=True)
# Deselect every Nth element starting from the active vertex, edge or face
bpy.ops.mesh.select_nth(nth=2, skip=1, offset=0)
# Select the previous element (using selection order)
bpy.ops.mesh.select_prev_item()
# Randomly select vertices
bpy.ops.mesh.select_random(percent=50, seed=0, action='SELECT')
# Select similar vertices, edges or faces by property types
bpy.ops.mesh.select_similar(type='NORMAL', compare='EQUAL', threshold=0)
# Select similar face regions to the current selection
bpy.ops.mesh.select_similar_region()
# Select vertices without a group
bpy.ops.mesh.select_ungrouped(extend=False)
# Separate selected geometry into a new mesh
bpy.ops.mesh.separate(type='SELECTED')
# Set the custom vertex normals from the selected faces ones
bpy.ops.mesh.set_normals_from_faces()
# Apply selected vertex locations to all other shape keys
bpy.ops.mesh.shape_propagate_to_all()
# Select shortest path between two selections
bpy.ops.mesh.shortest_path_pick(use_face_step=False, use_topology_distance=False, use_fill=False, nth=1, skip=1, offset=0, index=-1)
# Selected shortest path between two vertices/edges/faces
bpy.ops.mesh.shortest_path_select(use_face_step=False, use_topology_distance=False, use_fill=False, nth=1, skip=1, offset=0)
# Create a solid skin by extruding, compensating for sharp angles
bpy.ops.mesh.solidify(thickness=0.01)
# The order of selected vertices/edges/faces is modified, based on a given method
bpy.ops.mesh.sort_elements(type='VIEW_ZAXIS', elements={'VERT'}, reverse=False, seed=0)
# Extrude selected vertices in a circle around the cursor in indicated viewport
bpy.ops.mesh.spin(steps=9, dupli=False, angle=1.5708, center=(0, 0, 0), axis=(0, 0, 0))
# Split off selected geometry from connected unselected geometry
bpy.ops.mesh.split()
# Subdivide selected edges
bpy.ops.mesh.subdivide(number_cuts=1, smoothness=0, quadtri=False, quadcorner='STRAIGHT_CUT', fractal=0, fractal_along_normal=0, seed=0)
#
bpy.ops.mesh.subdivide_edgering(number_cuts=10, interpolation='PATH', smoothness=1, profile_shape_factor=0, profile_shape='SMOOTH')
# Enforce symmetry (both form and topological) across an axis
bpy.ops.mesh.symmetrize(direction='NEGATIVE_X', threshold=0.0001)
# Snap vertex pairs to their mirrored locations
bpy.ops.mesh.symmetry_snap(direction='NEGATIVE_X', threshold=0.05, factor=0.5, use_center=True)
# Join triangles into quads
bpy.ops.mesh.tris_convert_to_quads(face_threshold=0.698132, shape_threshold=0.698132, uvs=False, vcols=False, seam=False, sharp=False, materials=False)
# UnSubdivide selected edges & faces
bpy.ops.mesh.unsubdivide(iterations=2)
# Add UV Map
bpy.ops.mesh.uv_texture_add()
# Remove UV Map
bpy.ops.mesh.uv_texture_remove()
# Flip direction of UV coordinates inside faces
bpy.ops.mesh.uvs_reverse()
# Rotate UV coordinates inside faces
bpy.ops.mesh.uvs_rotate(use_ccw=False)
# Connect selected vertices of faces, splitting the face
bpy.ops.mesh.vert_connect()
# Make all faces convex
bpy.ops.mesh.vert_connect_concave()
# Split non-planar faces that exceed the angle threshold
bpy.ops.mesh.vert_connect_nonplanar(angle_limit=0.0872665)
# Connect vertices by their selection order, creating edges, splitting faces
bpy.ops.mesh.vert_connect_path()
# Add vertex color layer
bpy.ops.mesh.vertex_color_add()
# Remove vertex color layer
bpy.ops.mesh.vertex_color_remove()
# Flatten angles of selected vertices
bpy.ops.mesh.vertices_smooth(factor=0.5, repeat=1, xaxis=True, yaxis=True, zaxis=True)
# Laplacian smooth of selected vertices
bpy.ops.mesh.vertices_smooth_laplacian(repeat=1, lambda_factor=5e-005, lambda_border=5e-005, use_x=True, use_y=True, use_z=True, preserve_volume=True)
# Create a solid wire-frame from faces
bpy.ops.mesh.wireframe(use_boundary=True, use_even_offset=True, use_relative_offset=False, use_replace=True, thickness=0.01, offset=0.01, use_crease=False, crease_weight=0.01)

# Push action down onto the top of the NLA stack as a new strip
bpy.ops.nla.action_pushdown(channel_index=-1)
# Synchronize the length of the referenced Action with the length used in the strip
bpy.ops.nla.action_sync_length(active=True)
# Unlink this action from the active action slot (and/or exit Tweak Mode)
bpy.ops.nla.action_unlink(force_delete=False)
# Add an Action-Clip strip (i.e. an NLA Strip referencing an Action) to the active track
bpy.ops.nla.actionclip_add(action='<UNKNOWN ENUM>')
# Apply scaling of selected strips to their referenced Actions
bpy.ops.nla.apply_scale()
# Bake object/pose loc/scale/rotation animation to a new action
bpy.ops.nla.bake(frame_start=1, frame_end=250, step=1, only_selected=True, visual_keying=False, clear_constraints=False, clear_parents=False, use_current_action=False, bake_types={'POSE'})
# Handle clicks to select NLA channels
bpy.ops.nla.channels_click(extend=False)
# Reset scaling of selected strips
bpy.ops.nla.clear_scale()
# Handle clicks to select NLA Strips
bpy.ops.nla.click_select(extend=False)
# Delete selected strips
bpy.ops.nla.delete()
# Duplicate selected NLA-Strips, adding the new strips in new tracks above the originals
bpy.ops.nla.duplicate(linked=False, mode='TRANSLATION')
# Add F-Modifier to the active/selected NLA-Strips
bpy.ops.nla.fmodifier_add(type='NULL', only_active=True)
# Copy the F-Modifier(s) of the active NLA-Strip
bpy.ops.nla.fmodifier_copy()
# Add copied F-Modifiers to the selected NLA-Strips
bpy.ops.nla.fmodifier_paste(only_active=True, replace=False)
# Ensure that each action is only used once in the set of strips selected
bpy.ops.nla.make_single_user()
# Add new meta-strips incorporating the selected strips
bpy.ops.nla.meta_add()
# Separate out the strips held by the selected meta-strips
bpy.ops.nla.meta_remove()
# Move selected strips down a track if there's room
bpy.ops.nla.move_down()
# Move selected strips up a track if there's room
bpy.ops.nla.move_up()
# Mute or un-mute selected strips
bpy.ops.nla.mute_toggle()
# Automatically set Preview Range based on range of keyframes
bpy.ops.nla.previewrange_set()
# Toggle the properties region visibility
bpy.ops.nla.properties()
# Select or deselect all NLA-Strips
bpy.ops.nla.select_all_toggle(invert=False)
# Use box selection to grab NLA-Strips
bpy.ops.nla.select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True, axis_range=False)
# Select strips to the left or the right of the current frame
bpy.ops.nla.select_leftright(mode='CHECK', extend=False)
# Make selected objects appear in NLA Editor by adding Animation Data
bpy.ops.nla.selected_objects_add()
# Move start of strips to specified time
bpy.ops.nla.snap(type='CFRA')
# Add a strip for controlling when speaker plays its sound clip
bpy.ops.nla.soundclip_add()
# Split selected strips at their midpoints
bpy.ops.nla.split()
# Swap order of selected strips within tracks
bpy.ops.nla.swap()
# Add NLA-Tracks above/after the selected tracks
bpy.ops.nla.tracks_add(above_selected=False)
# Delete selected NLA-Tracks and the strips they contain
bpy.ops.nla.tracks_delete()
# Add a transition strip between two adjacent selected strips
bpy.ops.nla.transition_add()
# Enter tweaking mode for the action referenced by the active strip to edit its keyframes
bpy.ops.nla.tweakmode_enter(isolate_action=False)
# Exit tweaking mode for the action referenced by the active strip
bpy.ops.nla.tweakmode_exit(isolate_action=False)
# Reset viewable area to show full strips range
bpy.ops.nla.view_all()
# Reset viewable area to show range around current frame
bpy.ops.nla.view_frame()
# Reset viewable area to show selected strips range
bpy.ops.nla.view_selected()

# Add a node to the active tree and link to an existing socket
bpy.ops.node.add_and_link_node(settings=[], use_transform=False, type="", link_socket_index=0)
# Add a file node to the current node editor
bpy.ops.node.add_file(filepath="", filter_blender=False, filter_backup=False, filter_image=True, filter_movie=True, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, relative_path=True, show_multiview=False, use_multiview=False, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', name="Image")
# Add a mask node to the current node editor
bpy.ops.node.add_mask(name="Mask")
# Add a node to the active tree
bpy.ops.node.add_node(settings=[], use_transform=False, type="")
# Add a reroute node
bpy.ops.node.add_reroute(path=[], cursor=6)
# Add a node to the active tree
bpy.ops.node.add_search(settings=[], use_transform=False, type="", node_item='<UNKNOWN ENUM>')
# Attach active node to a frame
bpy.ops.node.attach()
# Fit the background image to the view
bpy.ops.node.backimage_fit()
# Move Node backdrop
bpy.ops.node.backimage_move()
# Use mouse to sample background image
bpy.ops.node.backimage_sample()
# Zoom in/out the background image
bpy.ops.node.backimage_zoom(factor=1.2)
# Clear the boundaries for viewer operations
bpy.ops.node.clear_viewer_border()
# Copies selected nodes to the clipboard
bpy.ops.node.clipboard_copy()
# Pastes nodes from the clipboard to the active node tree
bpy.ops.node.clipboard_paste()
# Toggle collapsed nodes and hide unused sockets
bpy.ops.node.collapse_hide_unused_toggle()
# Delete selected nodes
bpy.ops.node.delete()
# Delete nodes; will reconnect nodes as if deletion was muted
bpy.ops.node.delete_reconnect()
# Detach selected nodes from parents
bpy.ops.node.detach()
# Detach nodes, move and attach to frame
bpy.ops.node.detach_translate_attach(NODE_OT_detach={}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False}, NODE_OT_attach={})
# Duplicate selected nodes
bpy.ops.node.duplicate(keep_inputs=False)
# Duplicate selected nodes and move them
bpy.ops.node.duplicate_move(NODE_OT_duplicate={"keep_inputs":False}, NODE_OT_translate_attach={"TRANSFORM_OT_translate":{"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False}, "NODE_OT_attach":{}, "NODE_OT_insert_offset":{}})
# Duplicate selected nodes keeping input links and move them
bpy.ops.node.duplicate_move_keep_inputs(NODE_OT_duplicate={"keep_inputs":False}, NODE_OT_translate_attach={"TRANSFORM_OT_translate":{"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False}, "NODE_OT_attach":{}, "NODE_OT_insert_offset":{}})
# Search for named node and allow to select and activate it
bpy.ops.node.find_node(prev=False)
# Edit node group
bpy.ops.node.group_edit(exit=False)
# Insert selected nodes into a node group
bpy.ops.node.group_insert()
# Make group from selected nodes
bpy.ops.node.group_make()
# Separate selected nodes from the node group
bpy.ops.node.group_separate(type='COPY')
# Ungroup selected nodes
bpy.ops.node.group_ungroup()
# Toggle unused node socket display
bpy.ops.node.hide_socket_toggle()
# Toggle hiding of selected nodes
bpy.ops.node.hide_toggle()
# Automatically offset nodes on insertion
bpy.ops.node.insert_offset()
# Attach selected nodes to a new common frame
bpy.ops.node.join()
# Use the mouse to create a link between two nodes
bpy.ops.node.link(detach=False)
# Makes a link between selected output in input sockets
bpy.ops.node.link_make(replace=False)
# Link to viewer node
bpy.ops.node.link_viewer()
# Use the mouse to cut (remove) some links
bpy.ops.node.links_cut(path=[], cursor=9)
# Remove all links to selected nodes, and try to connect neighbor nodes together
bpy.ops.node.links_detach()
# Move a node to detach links
bpy.ops.node.move_detach_links(NODE_OT_links_detach={}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False}, NODE_OT_insert_offset={})
# Move a node to detach links
bpy.ops.node.move_detach_links_release(NODE_OT_links_detach={}, NODE_OT_translate_attach={"TRANSFORM_OT_translate":{"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False}, "NODE_OT_attach":{}, "NODE_OT_insert_offset":{}})
# Toggle muting of the nodes
bpy.ops.node.mute_toggle()
# Create a new node tree
bpy.ops.node.new_node_tree(type='ShaderNodeTree', name="NodeTree")
# Add or remove a Node Color Preset
bpy.ops.node.node_color_preset_add(name="", remove_active=False)
# Copy color to all selected nodes
bpy.ops.node.node_copy_color()
# Toggle option buttons display for selected nodes
bpy.ops.node.options_toggle()
# Add a new input to a file output node
bpy.ops.node.output_file_add_socket(file_path="Image")
# Move the active input of a file output node up or down the list
bpy.ops.node.output_file_move_active_socket(direction='DOWN')
# Remove active input from a file output node
bpy.ops.node.output_file_remove_active_socket()
# Attach selected nodes
bpy.ops.node.parent_set()
# Toggle preview display for selected nodes
bpy.ops.node.preview_toggle()
# Toggle the properties region visibility
bpy.ops.node.properties()
# Read all render layers of current scene, in full sample
bpy.ops.node.read_fullsamplelayers()
# Read all render layers of all used scenes
bpy.ops.node.read_renderlayers()
# Render current scene, when input node's layer has been changed
bpy.ops.node.render_changed()
# Resize a node
bpy.ops.node.resize()
# Select the node under the cursor
bpy.ops.node.select(mouse_x=0, mouse_y=0, extend=False)
# (De)select all nodes
bpy.ops.node.select_all(action='TOGGLE')
# Use box selection to select nodes
bpy.ops.node.select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True, tweak=False)
# Use circle selection to select nodes
bpy.ops.node.select_circle(x=0, y=0, radius=1, gesture_mode=0)
# Select nodes with similar properties
bpy.ops.node.select_grouped(extend=False, type='TYPE')
# Select nodes using lasso selection
bpy.ops.node.select_lasso(path=[], deselect=False, extend=True)
# Select node and link it to a viewer node
bpy.ops.node.select_link_viewer(NODE_OT_select={"mouse_x":0, "mouse_y":0, "extend":False}, NODE_OT_link_viewer={})
# Select nodes linked from the selected ones
bpy.ops.node.select_linked_from()
# Select nodes linked to the selected ones
bpy.ops.node.select_linked_to()
# Activate and view same node type, step by step
bpy.ops.node.select_same_type_step(prev=False)
# Update shader script node with new sockets and options from the script
bpy.ops.node.shader_script_update()
# Update views of selected node
bpy.ops.node.switch_view_update()
# Toggles tool shelf display
bpy.ops.node.toolbar()
# Move nodes and attach to frame
bpy.ops.node.translate_attach(TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False}, NODE_OT_attach={}, NODE_OT_insert_offset={})
# Move nodes and attach to frame
bpy.ops.node.translate_attach_remove_on_cancel(TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False}, NODE_OT_attach={}, NODE_OT_insert_offset={})
# Go to parent node tree
bpy.ops.node.tree_path_parent()
# Add an input or output socket to the current node tree
bpy.ops.node.tree_socket_add(in_out='IN')
# Move a socket up or down in the current node tree's sockets stack
bpy.ops.node.tree_socket_move(direction='UP')
# Remove an input or output socket to the current node tree
bpy.ops.node.tree_socket_remove()
# Resize view so you can see all nodes
bpy.ops.node.view_all()
# Resize view so you can see selected nodes
bpy.ops.node.view_selected()
# Set the boundaries for viewer operations
bpy.ops.node.viewer_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)

# Add an object to the scene
bpy.ops.object.add(radius=1, type='EMPTY', view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Add named object
bpy.ops.object.add_named(linked=False, name="")
# Align Objects
bpy.ops.object.align(bb_quality=True, align_mode='OPT_2', relative_to='OPT_4', align_axis=set())
# Convert object animation for normal transforms to delta transforms
bpy.ops.object.anim_transforms_to_deltas()
# Add an armature object to the scene
bpy.ops.object.armature_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Bake image textures of selected objects
bpy.ops.object.bake(type='COMBINED', pass_filter=set(), filepath="", width=512, height=512, margin=16, use_selected_to_active=False, cage_extrusion=0, cage_object="", normal_space='TANGENT', normal_r='POS_X', normal_g='POS_Y', normal_b='POS_Z', save_mode='INTERNAL', use_clear=False, use_cage=False, use_split_materials=False, use_automatic_name=False, uv_layer="")
# Bake image textures of selected objects
bpy.ops.object.bake_image()
# Add a camera object to the scene
bpy.ops.object.camera_add(view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Add a constraint to the active object
bpy.ops.object.constraint_add(type='<UNKNOWN ENUM>')
# Add a constraint to the active object, with target (where applicable) set to the selected Objects/Bones
bpy.ops.object.constraint_add_with_targets(type='<UNKNOWN ENUM>')
# Clear all the constraints for the active Object only
bpy.ops.object.constraints_clear()
# Copy constraints to other selected objects
bpy.ops.object.constraints_copy()
# Convert selected objects to another type
bpy.ops.object.convert(target='MESH', keep_original=False)
# Bind base pose in Corrective Smooth modifier
bpy.ops.object.correctivesmooth_bind(modifier="")
# Transfer data layer(s) (weights, edge sharp, ...) from active to selected meshes
bpy.ops.object.data_transfer(use_reverse_transfer=False, use_freeze=False, data_type='<UNKNOWN ENUM>', use_create=True, vert_mapping='NEAREST', edge_mapping='NEAREST', loop_mapping='NEAREST_POLYNOR', poly_mapping='NEAREST', use_auto_transform=False, use_object_transform=True, use_max_distance=False, max_distance=1, ray_radius=0, islands_precision=0.1, layers_select_src='ACTIVE', layers_select_dst='ACTIVE', mix_mode='REPLACE', mix_factor=1)
# Transfer layout of data layer(s) from active to selected meshes
bpy.ops.object.datalayout_transfer(modifier="", data_type='<UNKNOWN ENUM>', use_delete=False, layers_select_src='ACTIVE', layers_select_dst='ACTIVE')
# Delete selected objects
bpy.ops.object.delete(use_global=False)
# Add an empty image type to scene with data
bpy.ops.object.drop_named_image(filepath="", relative_path=True, name="", view_align=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
#
bpy.ops.object.drop_named_material(name="Material")
# Set offset used for DupliGroup based on cursor position
bpy.ops.object.dupli_offset_from_cursor()
# Duplicate selected objects
bpy.ops.object.duplicate(linked=False, mode='TRANSLATION')
# Duplicate selected objects and move them
bpy.ops.object.duplicate_move(OBJECT_OT_duplicate={"linked":False, "mode":'TRANSLATION'}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Duplicate selected objects and move them
bpy.ops.object.duplicate_move_linked(OBJECT_OT_duplicate={"linked":False, "mode":'TRANSLATION'}, TRANSFORM_OT_translate={"value":(0, 0, 0), "constraint_axis":(False, False, False), "constraint_orientation":'GLOBAL', "mirror":False, "proportional":'DISABLED', "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "texture_space":False, "remove_on_cancel":False, "release_confirm":False, "use_accurate":False})
# Make dupli objects attached to this object real
bpy.ops.object.duplicates_make_real(use_base_parent=False, use_hierarchy=False)
# Toggle object's editmode
bpy.ops.object.editmode_toggle()
# Add an empty object with a physics effector to the scene
bpy.ops.object.effector_add(type='FORCE', radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Add an empty object to the scene
bpy.ops.object.empty_add(type='PLAIN_AXES', radius=1, view_align=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Refresh data in the Explode modifier
bpy.ops.object.explode_refresh(modifier="")
# Toggle object's force field
bpy.ops.object.forcefield_toggle()
# Copy game physics properties to other selected objects
bpy.ops.object.game_physics_copy()
# Remove all game properties from all selected objects
bpy.ops.object.game_property_clear()
# Copy/merge/replace a game property from active object to all selected objects
bpy.ops.object.game_property_copy(operation='COPY', property='<UNKNOWN ENUM>')
# Move game property
bpy.ops.object.game_property_move(index=0, direction='UP')
# Create a new property available to the game engine
bpy.ops.object.game_property_new(type='FLOAT', name="")
# Remove game property
bpy.ops.object.game_property_remove(index=0)
# Add an object to a new group
bpy.ops.object.group_add()
# Add a dupligroup instance
bpy.ops.object.group_instance_add(name="Group", group='<UNKNOWN ENUM>', view_align=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Add an object to an existing group
bpy.ops.object.group_link(group='<UNKNOWN ENUM>')
# Remove the active object from this group
bpy.ops.object.group_remove()
# Unlink the group from all objects
bpy.ops.object.group_unlink()
# Select all objects in group
bpy.ops.object.grouped_select()
# Reveal the render object by setting the hide render flag
bpy.ops.object.hide_render_clear()
# Reveal all render objects by setting the hide render flag
bpy.ops.object.hide_render_clear_all()
# Hide the render object by setting the hide render flag
bpy.ops.object.hide_render_set(unselected=False)
# Reveal the object by setting the hide flag
bpy.ops.object.hide_view_clear()
# Hide the object by setting the hide flag
bpy.ops.object.hide_view_set(unselected=False)
# Hook selected vertices to a newly created object
bpy.ops.object.hook_add_newob()
# Hook selected vertices to the first selected object
bpy.ops.object.hook_add_selob(use_bone=False)
# Assign the selected vertices to a hook
bpy.ops.object.hook_assign(modifier='<UNKNOWN ENUM>')
# Set hook center to cursor position
bpy.ops.object.hook_recenter(modifier='<UNKNOWN ENUM>')
# Remove a hook from the active object
bpy.ops.object.hook_remove(modifier='<UNKNOWN ENUM>')
# Recalculate and clear offset transformation
bpy.ops.object.hook_reset(modifier='<UNKNOWN ENUM>')
# Select affected vertices on mesh
bpy.ops.object.hook_select(modifier='<UNKNOWN ENUM>')
# Hide unselected render objects of same type as active by setting the hide render flag
bpy.ops.object.isolate_type_render()
# Join selected objects into active object
bpy.ops.object.join()
# Merge selected objects to shapes of active object
bpy.ops.object.join_shapes()
# Transfer UV Maps from active to selected objects (needs matching geometry)
bpy.ops.object.join_uvs()
# Add a lamp object to the scene
bpy.ops.object.lamp_add(type='POINT', radius=1, view_align=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Bind mesh to system in laplacian deform modifier
bpy.ops.object.laplaciandeform_bind(modifier="")
# Clear the object's location
bpy.ops.object.location_clear(clear_delta=False)
# Add a level of detail to this object
bpy.ops.object.lod_add()
# Add levels of detail to this object based on object names
bpy.ops.object.lod_by_name()
# Remove all levels of detail from this object
bpy.ops.object.lod_clear_all()
# Generate levels of detail using the decimate modifier
bpy.ops.object.lod_generate(count=3, target=0.1, package=False)
# Remove a level of detail from this object
bpy.ops.object.lod_remove(index=1)
# Copy logic bricks to other selected objects
bpy.ops.object.logic_bricks_copy()
# Convert objects into dupli-face instanced
bpy.ops.object.make_dupli_face()
# Apply active object links to other selected objects
bpy.ops.object.make_links_data(type='OBDATA')
# Link selection to another scene
bpy.ops.object.make_links_scene(scene='Scene')
# Make library linked data-blocks local to this file
bpy.ops.object.make_local(type='SELECT_OBJECT')
# Make linked data local to each object
bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=False, obdata=False, material=False, texture=False, animation=False)
# Add a new material slot
bpy.ops.object.material_slot_add()
# Assign active material slot to selection
bpy.ops.object.material_slot_assign()
# Copies materials to other selected objects
bpy.ops.object.material_slot_copy()
# Deselect by active material slot
bpy.ops.object.material_slot_deselect()
# Move the active material up/down in the list
bpy.ops.object.material_slot_move(direction='UP')
# Remove the selected material slot
bpy.ops.object.material_slot_remove()
# Select by active material slot
bpy.ops.object.material_slot_select()
# Bind mesh to cage in mesh deform modifier
bpy.ops.object.meshdeform_bind(modifier="")
# Add an metaball object to the scene
bpy.ops.object.metaball_add(type='BALL', radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Sets the object interaction mode
bpy.ops.object.mode_set(mode='OBJECT', toggle=False)
# Add a procedural operation/effect to the active object
bpy.ops.object.modifier_add(type='SUBSURF')
# Apply modifier and remove from the stack
bpy.ops.object.modifier_apply(apply_as='DATA', modifier="")
# Convert particles to a mesh object
bpy.ops.object.modifier_convert(modifier="")
# Duplicate modifier at the same position in the stack
bpy.ops.object.modifier_copy(modifier="")
# Move modifier down in the stack
bpy.ops.object.modifier_move_down(modifier="")
# Move modifier up in the stack
bpy.ops.object.modifier_move_up(modifier="")
# Remove a modifier from the active object
bpy.ops.object.modifier_remove(modifier="")
# Move the object to different layers
bpy.ops.object.move_to_layer(layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Modify the base mesh to conform to the displaced mesh
bpy.ops.object.multires_base_apply(modifier="")
# Pack displacements from an external file
bpy.ops.object.multires_external_pack()
# Save displacements to an external file
bpy.ops.object.multires_external_save(filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=True, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, relative_path=True, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', modifier="")
# Deletes the higher resolution mesh, potential loss of detail
bpy.ops.object.multires_higher_levels_delete(modifier="")
# Copy vertex coordinates from other object
bpy.ops.object.multires_reshape(modifier="")
# Add a new level of subdivision
bpy.ops.object.multires_subdivide(modifier="")
# Bake an image sequence of ocean data
bpy.ops.object.ocean_bake(modifier="", free=False)
# Clear the object's origin
bpy.ops.object.origin_clear()
# Set the object's origin, by either moving the data, or set to center of data, or use 3D cursor
bpy.ops.object.origin_set(type='GEOMETRY_ORIGIN', center='MEDIAN')
# Clear the object's parenting
bpy.ops.object.parent_clear(type='CLEAR')
# Set the object's parenting without setting the inverse parent correction
bpy.ops.object.parent_no_inverse_set()
# Set the object's parenting
bpy.ops.object.parent_set(type='OBJECT', xmirror=False, keep_transform=False)
# Add a particle system
bpy.ops.object.particle_system_add()
# Remove the selected particle system
bpy.ops.object.particle_system_remove()
# Calculate motion paths for the selected objects
bpy.ops.object.paths_calculate(start_frame=1, end_frame=250)
# Clear path caches for all objects, hold Shift key for selected objects only
bpy.ops.object.paths_clear(only_selected=False)
# Recalculate paths for selected objects
bpy.ops.object.paths_update()
# Enable or disable posing/selecting bones
bpy.ops.object.posemode_toggle()
# Add empty object to become local replacement data of a library-linked object
bpy.ops.object.proxy_make(object='DEFAULT')
#
bpy.ops.object.quick_explode(style='EXPLODE', amount=100, frame_duration=50, frame_start=1, frame_end=10, velocity=1, fade=True)
#
bpy.ops.object.quick_fluid(style='BASIC', initial_velocity=(0, 0, 0), show_flows=False, start_baking=False)
#
bpy.ops.object.quick_fur(density='MEDIUM', view_percentage=10, length=0.1)
#
bpy.ops.object.quick_smoke(style='SMOKE', show_flows=False)
# Randomize objects loc/rot/scale
bpy.ops.object.randomize_transform(random_seed=0, use_delta=False, use_loc=True, loc=(0, 0, 0), use_rot=True, rot=(0, 0, 0), use_scale=True, scale_even=False, scale=(1, 1, 1))
# Clear the object's rotation
bpy.ops.object.rotation_clear(clear_delta=False)
# Clear the object's scale
bpy.ops.object.scale_clear(clear_delta=False)
# Change selection of all visible objects in scene
bpy.ops.object.select_all(action='TOGGLE')
# Select all visible objects on a layer
bpy.ops.object.select_by_layer(match='EXACT', extend=False, layers=1)
# Select all visible objects that are of a type
bpy.ops.object.select_by_type(extend=False, type='MESH')
# Select the active camera
bpy.ops.object.select_camera(extend=False)
# Select all visible objects grouped by various properties
bpy.ops.object.select_grouped(extend=False, type='CHILDREN_RECURSIVE')
# Select object relative to the active object's position in the hierarchy
bpy.ops.object.select_hierarchy(direction='PARENT', extend=False)
# Deselect objects at the boundaries of parent/child relationships
bpy.ops.object.select_less()
# Select all visible objects that are linked
bpy.ops.object.select_linked(extend=False, type='OBDATA')
# Select the Mirror objects of the selected object eg. L.sword -> R.sword
bpy.ops.object.select_mirror(extend=False)
# Select connected parent/child objects
bpy.ops.object.select_more()
# Select objects matching a naming pattern
bpy.ops.object.select_pattern(pattern="*", case_sensitive=False, extend=True)
# Set select on random visible objects
bpy.ops.object.select_random(percent=50, seed=0, action='SELECT')
# Select object in the same group
bpy.ops.object.select_same_group(group="")
# Render and display faces uniform, using Face Normals
bpy.ops.object.shade_flat()
# Render and display faces smooth, using interpolated Vertex Normals
bpy.ops.object.shade_smooth()
# Add shape key to the object
bpy.ops.object.shape_key_add(from_mix=True)
# Clear weights for all shape keys
bpy.ops.object.shape_key_clear()
# Mirror the current shape key along the local X axis
bpy.ops.object.shape_key_mirror(use_topology=False)
# Move the active shape key up/down in the list
bpy.ops.object.shape_key_move(type='TOP')
# Remove shape key from the object
bpy.ops.object.shape_key_remove(all=False)
# Resets the timing for absolute shape keys
bpy.ops.object.shape_key_retime()
# Copy another selected objects active shape to this one by applying the relative offsets
bpy.ops.object.shape_key_transfer(mode='OFFSET', use_clamp=False)
# Create an armature that parallels the skin layout
bpy.ops.object.skin_armature_create(modifier="")
# Mark/clear selected vertices as loose
bpy.ops.object.skin_loose_mark_clear(action='MARK')
# Make skin radii of selected vertices equal on each axis
bpy.ops.object.skin_radii_equalize()
# Mark selected vertices as roots
bpy.ops.object.skin_root_mark()
# Clear the object's slow parent
bpy.ops.object.slow_parent_clear()
# Set the object's slow parent
bpy.ops.object.slow_parent_set()
# Add a speaker object to the scene
bpy.ops.object.speaker_add(view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Sets a Subdivision Surface Level (1-5)
bpy.ops.object.subdivision_set(level=1, relative=False)
# Bind mesh to target in surface deform modifier
bpy.ops.object.surfacedeform_bind(modifier="")
# Add a text object to the scene
bpy.ops.object.text_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Clear tracking constraint or flag from object
bpy.ops.object.track_clear(type='CLEAR')
# Make the object track another object, using various methods/constraints
bpy.ops.object.track_set(type='DAMPTRACK')
# Apply the object's transformation to its data
bpy.ops.object.transform_apply(location=False, rotation=False, scale=False)
# Convert normal object transforms to delta transforms, any existing delta transforms will be included as well
bpy.ops.object.transforms_to_deltas(mode='ALL', reset_values=True)
#
bpy.ops.object.unlink_data()
# Add a new vertex group to the active object
bpy.ops.object.vertex_group_add()
# Assign the selected vertices to the active vertex group
bpy.ops.object.vertex_group_assign()
# Assign the selected vertices to a new vertex group
bpy.ops.object.vertex_group_assign_new()
# Remove vertex group assignments which are not required
bpy.ops.object.vertex_group_clean(group_select_mode='ACTIVE', limit=0, keep_single=False)
# Make a copy of the active vertex group
bpy.ops.object.vertex_group_copy()
# Replace vertex groups of all users of the same geometry data by vertex groups of active object
bpy.ops.object.vertex_group_copy_to_linked()
# Replace vertex groups of selected objects by vertex groups of active object
bpy.ops.object.vertex_group_copy_to_selected()
# Deselect all selected vertices assigned to the active vertex group
bpy.ops.object.vertex_group_deselect()
# Modify the position of selected vertices by changing only their respective groups' weights (this tool may be slow for many vertices)
bpy.ops.object.vertex_group_fix(dist=0, strength=1, accuracy=1)
# Invert active vertex group's weights
bpy.ops.object.vertex_group_invert(group_select_mode='ACTIVE', auto_assign=True, auto_remove=True)
# Add some offset and multiply with some gain the weights of the active vertex group
bpy.ops.object.vertex_group_levels(group_select_mode='ACTIVE', offset=0, gain=1)
# Limit deform weights associated with a vertex to a specified number by removing lowest weights
bpy.ops.object.vertex_group_limit_total(group_select_mode='ALL', limit=4)
# Change the lock state of all vertex groups of active object
bpy.ops.object.vertex_group_lock(action='TOGGLE')
# Mirror vertex group, flip weights and/or names, editing only selected vertices, flipping when both sides are selected otherwise copy from unselected
bpy.ops.object.vertex_group_mirror(mirror_weights=True, flip_group_names=True, all_groups=False, use_topology=False)
# Move the active vertex group up/down in the list
bpy.ops.object.vertex_group_move(direction='UP')
# Normalize weights of the active vertex group, so that the highest ones are now 1.0
bpy.ops.object.vertex_group_normalize()
# Normalize all weights of all vertex groups, so that for each vertex, the sum of all weights is 1.0
bpy.ops.object.vertex_group_normalize_all(group_select_mode='ALL', lock_active=True)
# Set weights to a fixed number of steps
bpy.ops.object.vertex_group_quantize(group_select_mode='ACTIVE', steps=4)
# Delete the active or all vertex groups from the active object
bpy.ops.object.vertex_group_remove(all=False, all_unlocked=False)
# Remove the selected vertices from active or all vertex group(s)
bpy.ops.object.vertex_group_remove_from(use_all_groups=False, use_all_verts=False)
# Select all the vertices assigned to the active vertex group
bpy.ops.object.vertex_group_select()
# Set the active vertex group
bpy.ops.object.vertex_group_set_active(group='<UNKNOWN ENUM>')
# Smooth weights for selected vertices
bpy.ops.object.vertex_group_smooth(group_select_mode='ACTIVE', factor=0.5, repeat=1, expand=0, source='ALL')
# Sort vertex groups
bpy.ops.object.vertex_group_sort(sort_type='NAME')
# Parent selected objects to the selected vertices
bpy.ops.object.vertex_parent_set()
# Copy weights from active to selected
bpy.ops.object.vertex_weight_copy()
# Delete this weight from the vertex (disabled if vertex group is locked)
bpy.ops.object.vertex_weight_delete(weight_group=-1)
# Normalize active vertex's weights
bpy.ops.object.vertex_weight_normalize_active_vertex()
# Copy this group's weight to other selected verts (disabled if vertex group is locked)
bpy.ops.object.vertex_weight_paste(weight_group=-1)
# Set as active vertex group
bpy.ops.object.vertex_weight_set_active(weight_group=-1)
# Apply the object's visual transformation to its data
bpy.ops.object.visual_transform_apply()

# Change the active action used
bpy.ops.outliner.action_set(action='<UNKNOWN ENUM>')
#
bpy.ops.outliner.animdata_operation(type='CLEAR_ANIMDATA')
#
bpy.ops.outliner.constraint_operation(type='ENABLE')
#
bpy.ops.outliner.data_operation(type='SELECT')
# Add drivers to selected items
bpy.ops.outliner.drivers_add_selected()
# Delete drivers assigned to selected items
bpy.ops.outliner.drivers_delete_selected()
# Expand/Collapse all items
bpy.ops.outliner.expanded_toggle()
# Link Object to Group in Outliner
bpy.ops.outliner.group_link(object="Object")
#
bpy.ops.outliner.group_operation(type='UNLINK')
# Delete the ID under cursor
bpy.ops.outliner.id_delete()
#
bpy.ops.outliner.id_operation(type='UNLINK')
#
bpy.ops.outliner.id_remap(id_type='OBJECT', old_id='Camera', new_id='Camera')
# Handle mouse clicks to activate/select items
bpy.ops.outliner.item_activate(extend=True, recursive=False)
# Toggle whether item under cursor is enabled or closed
bpy.ops.outliner.item_openclose(all=True)
# Rename item under cursor
bpy.ops.outliner.item_rename()
# Add selected items (blue-gray rows) to active Keying Set
bpy.ops.outliner.keyingset_add_selected()
# Remove selected items (blue-gray rows) from active Keying Set
bpy.ops.outliner.keyingset_remove_selected()
#
bpy.ops.outliner.lib_operation(type='RENAME')
# Relocate the library under cursor
bpy.ops.outliner.lib_relocate()
# Drag material to object in Outliner
bpy.ops.outliner.material_drop(object="Object", material="Material")
#
bpy.ops.outliner.modifier_operation(type='TOGVIS')
#
bpy.ops.outliner.object_operation(type='SELECT')
# Context menu for item operations
bpy.ops.outliner.operation()
# Clear all orphaned data-blocks without any users from the file (cannot be undone, saves to current .blend file)
bpy.ops.outliner.orphans_purge()
# Drag to clear parent in Outliner
bpy.ops.outliner.parent_clear(dragged_obj="Object", type='CLEAR')
# Drag to parent in Outliner
bpy.ops.outliner.parent_drop(child="Object", parent="Object", type='OBJECT')
# Toggle the renderability of selected items
bpy.ops.outliner.renderability_toggle()
# Drag object to scene in Outliner
bpy.ops.outliner.scene_drop(object="Object", scene="Scene")
# Context menu for scene operations
bpy.ops.outliner.scene_operation(type='DELETE')
# Scroll page up or down
bpy.ops.outliner.scroll_page(up=False)
# Use box selection to select tree elements
bpy.ops.outliner.select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0)
# Toggle the selectability
bpy.ops.outliner.selectability_toggle()
# Toggle the Outliner selection of items
bpy.ops.outliner.selected_toggle()
# Open up the tree and adjust the view so that the active Object is shown centered
bpy.ops.outliner.show_active()
# Open all object entries and close all others
bpy.ops.outliner.show_hierarchy()
# Expand/collapse all entries by one level
bpy.ops.outliner.show_one_level(open=True)
# Toggle the visibility of selected items
bpy.ops.outliner.visibility_toggle()

# Add cube map uvs on mesh
bpy.ops.paint.add_simple_uvs()
# Add a texture paint slot
bpy.ops.paint.add_texture_paint_slot(type='DIFFUSE_COLOR', name="Untitled", width=1024, height=1024, color=(0, 0, 0, 1), alpha=True, generated_type='BLANK', float=False)
# Toggle foreground and background brush colors
bpy.ops.paint.brush_colors_flip()
# Select a paint mode's brush by tool type
bpy.ops.paint.brush_select(paint_mode='ACTIVE', sculpt_tool='BLOB', vertex_paint_tool='MIX', weight_paint_tool='MIX', texture_paint_tool='DRAW', toggle=False, create_missing=False)
# Delete selected texture paint slot
bpy.ops.paint.delete_texture_paint_slot()
# Change selection for all faces
bpy.ops.paint.face_select_all(action='TOGGLE')
# Hide selected faces
bpy.ops.paint.face_select_hide(unselected=False)
# Select linked faces
bpy.ops.paint.face_select_linked()
# Select linked faces under the cursor
bpy.ops.paint.face_select_linked_pick(deselect=False)
# Reveal hidden faces
bpy.ops.paint.face_select_reveal(unselected=False)
# Move the clone source image
bpy.ops.paint.grab_clone(delta=(0, 0))
# Hide/show some vertices
bpy.ops.paint.hide_show(action='HIDE', area='INSIDE', xmin=0, xmax=0, ymin=0, ymax=0)
# Make an image from the current 3D view for re-projection
bpy.ops.paint.image_from_view(filepath="")
# Paint a stroke into the image
bpy.ops.paint.image_paint(stroke=[], mode='NORMAL')
# Fill the whole mask with a given value, or invert its values
bpy.ops.paint.mask_flood_fill(mode='VALUE', value=0)
# Add mask within the lasso as you move the brush
bpy.ops.paint.mask_lasso_gesture(path=[], mode='VALUE', value=1)
# Project an edited render from the active camera back onto the object
bpy.ops.paint.project_image(image='<UNKNOWN ENUM>')
# Use the mouse to sample a color in the image
bpy.ops.paint.sample_color(location=(0, 0), merged=False, palette=False)
# Toggle texture paint mode in 3D view
bpy.ops.paint.texture_paint_toggle()
# Change selection for all vertices
bpy.ops.paint.vert_select_all(action='TOGGLE')
# Select vertices without a group
bpy.ops.paint.vert_select_ungrouped(extend=False)
# Adjust vertex color brightness/contrast
bpy.ops.paint.vertex_color_brightness_contrast(brightness=0, contrast=0)
#
bpy.ops.paint.vertex_color_dirt(blur_strength=1, blur_iterations=1, clean_angle=3.14159, dirt_angle=0, dirt_only=False)
# Adjust vertex color HSV values
bpy.ops.paint.vertex_color_hsv(h=0.5, s=1, v=1)
# Invert RGB values
bpy.ops.paint.vertex_color_invert()
# Adjust levels of vertex colors
bpy.ops.paint.vertex_color_levels(offset=0, gain=1)
# Fill the active vertex color layer with the current paint color
bpy.ops.paint.vertex_color_set()
# Smooth colors across vertices
bpy.ops.paint.vertex_color_smooth()
# Paint a stroke in the active vertex color layer
bpy.ops.paint.vertex_paint(stroke=[], mode='NORMAL')
# Toggle the vertex paint mode in 3D view
bpy.ops.paint.vertex_paint_toggle()
# Set the weights of the groups matching the attached armature's selected bones, using the distance between the vertices and the bones
bpy.ops.paint.weight_from_bones(type='AUTOMATIC')
# Draw a line to apply a weight gradient to selected vertices
bpy.ops.paint.weight_gradient(type='LINEAR', xstart=0, xend=0, ystart=0, yend=0, cursor=1002)
# Paint a stroke in the current vertex group's weights
bpy.ops.paint.weight_paint(stroke=[], mode='NORMAL')
# Toggle weight paint mode in 3D view
bpy.ops.paint.weight_paint_toggle()
# Use the mouse to sample a weight in the 3D view
bpy.ops.paint.weight_sample()
# Select one of the vertex groups available under current mouse position
bpy.ops.paint.weight_sample_group(group='<UNKNOWN ENUM>')
# Fill the active vertex group with the current paint weight
bpy.ops.paint.weight_set()

# Add New Paint Curve Point
bpy.ops.paintcurve.add_point(location=(0, 0))
# Add new curve point and slide it
bpy.ops.paintcurve.add_point_slide(PAINTCURVE_OT_add_point={"location":(0, 0)}, PAINTCURVE_OT_slide={"align":False, "select":True})
# Place cursor
bpy.ops.paintcurve.cursor()
# Remove Paint Curve Point
bpy.ops.paintcurve.delete_point()
# Draw curve
bpy.ops.paintcurve.draw()
# Add new paint curve
bpy.ops.paintcurve.new()
# Select a paint curve point
bpy.ops.paintcurve.select(location=(0, 0), toggle=False, extend=False)
# Select and slide paint curve point
bpy.ops.paintcurve.slide(align=False, select=True)

# Add new color to active palette
bpy.ops.palette.color_add()
# Remove active color from palette
bpy.ops.palette.color_delete()
# Add new palette
bpy.ops.palette.new()

# Apply a stroke of brush to the particles
bpy.ops.particle.brush_edit(stroke=[])
# Connect hair to the emitter mesh
bpy.ops.particle.connect_hair(all=False)
# Copy particle systems from the active object to selected objects
bpy.ops.particle.copy_particle_systems(space='OBJECT', remove_target_particles=True, use_active=False)
# Delete selected particles or keys
bpy.ops.particle.delete(type='PARTICLE')
# Disconnect hair from the emitter mesh
bpy.ops.particle.disconnect_hair(all=False)
# Duplicate particle system within the active object
bpy.ops.particle.duplicate_particle_system(use_duplicate_settings=False)
# Duplicate the current dupliobject
bpy.ops.particle.dupliob_copy()
# Move dupli object down in the list
bpy.ops.particle.dupliob_move_down()
# Move dupli object up in the list
bpy.ops.particle.dupliob_move_up()
# Remove the selected dupliobject
bpy.ops.particle.dupliob_remove()
# Undo all edition performed on the particle system
bpy.ops.particle.edited_clear()
# Add or remove a Hair Dynamics Preset
bpy.ops.particle.hair_dynamics_preset_add(name="", remove_active=False)
# Hide selected particles
bpy.ops.particle.hide(unselected=False)
# Duplicate and mirror the selected particles along the local X axis
bpy.ops.particle.mirror()
# Add new particle settings
bpy.ops.particle.new()
# Add a new particle target
bpy.ops.particle.new_target()
# Toggle particle edit mode
bpy.ops.particle.particle_edit_toggle()
# Change the number of keys of selected particles (root and tip keys included)
bpy.ops.particle.rekey(keys_number=2)
# Remove selected particles close enough of others
bpy.ops.particle.remove_doubles(threshold=0.0002)
# Show hidden particles
bpy.ops.particle.reveal()
# (De)select all particles' keys
bpy.ops.particle.select_all(action='TOGGLE')
# Deselect boundary selected keys of each particle
bpy.ops.particle.select_less()
# Select nearest particle from mouse pointer
bpy.ops.particle.select_linked(deselect=False, location=(0, 0))
# Select keys linked to boundary selected keys of each particle
bpy.ops.particle.select_more()
# Select a randomly distributed set of hair or points
bpy.ops.particle.select_random(percent=50, seed=0, action='SELECT', type='HAIR')
# Select roots of all visible particles
bpy.ops.particle.select_roots(action='SELECT')
# Select tips of all visible particles
bpy.ops.particle.select_tips(action='SELECT')
# Cut hair to conform to the set shape object
bpy.ops.particle.shape_cut()
# Subdivide selected particles segments (adds keys)
bpy.ops.particle.subdivide()
# Move particle target down in the list
bpy.ops.particle.target_move_down()
# Move particle target up in the list
bpy.ops.particle.target_move_up()
# Remove the selected particle target
bpy.ops.particle.target_remove()
# Make selected hair the same length
bpy.ops.particle.unify_length()
# Set the weight of selected keys
bpy.ops.particle.weight_set(factor=1)

# Apply the current pose as the new rest pose
bpy.ops.pose.armature_apply()
# Automatically renames the selected bones according to which side of the target axis they fall on
bpy.ops.pose.autoside_names(axis='XAXIS')
# Change the layers that the selected bones belong to
bpy.ops.pose.bone_layers(layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Create a suitable breakdown pose on the current frame
bpy.ops.pose.breakdown(percentage=0.5, prev_frame=0, next_frame=0, channels='ALL', axis_lock='FREE')
# Add a constraint to the active bone
bpy.ops.pose.constraint_add(type='<UNKNOWN ENUM>')
# Add a constraint to the active bone, with target (where applicable) set to the selected Objects/Bones
bpy.ops.pose.constraint_add_with_targets(type='<UNKNOWN ENUM>')
# Clear all the constraints for the selected bones
bpy.ops.pose.constraints_clear()
# Copy constraints to other selected bones
bpy.ops.pose.constraints_copy()
# Copies the current pose of the selected bones to copy/paste buffer
bpy.ops.pose.copy()
# Flips (and corrects) the axis suffixes of the names of selected bones
bpy.ops.pose.flip_names()
# Add a new bone group
bpy.ops.pose.group_add()
# Add selected bones to the chosen bone group
bpy.ops.pose.group_assign(type=0)
# Deselect bones of active Bone Group
bpy.ops.pose.group_deselect()
# Change position of active Bone Group in list of Bone Groups
bpy.ops.pose.group_move(direction='UP')
# Remove the active bone group
bpy.ops.pose.group_remove()
# Select bones in active Bone Group
bpy.ops.pose.group_select()
# Sort Bone Groups by their names in ascending order
bpy.ops.pose.group_sort()
# Remove selected bones from all bone groups
bpy.ops.pose.group_unassign()
# Tag selected bones to not be visible in Pose Mode
bpy.ops.pose.hide(unselected=False)
# Add IK Constraint to the active Bone
bpy.ops.pose.ik_add(with_targets=True)
# Remove all IK Constraints from selected bones
bpy.ops.pose.ik_clear()
# Reset locations of selected bones to their default values
bpy.ops.pose.loc_clear()
# Paste the stored pose on to the current pose
bpy.ops.pose.paste(flipped=False, selected_mask=False)
# Calculate paths for the selected bones
bpy.ops.pose.paths_calculate(start_frame=1, end_frame=250, bake_location='TAILS')
# Clear path caches for all bones, hold Shift key for selected bones only
bpy.ops.pose.paths_clear(only_selected=False)
# Recalculate paths for bones that already have them
bpy.ops.pose.paths_update()
# Copy selected aspects of the current pose to subsequent poses already keyframed
bpy.ops.pose.propagate(mode='WHILE_HELD', end_frame=250)
# Exaggerate the current pose
bpy.ops.pose.push(percentage=0.5, prev_frame=0, next_frame=0, channels='ALL', axis_lock='FREE')
# Flip quaternion values to achieve desired rotations, while maintaining the same orientations
bpy.ops.pose.quaternions_flip()
# Make the current pose more similar to its surrounding ones
bpy.ops.pose.relax(percentage=0.5, prev_frame=0, next_frame=0, channels='ALL', axis_lock='FREE')
# Unhide all bones that have been tagged to be hidden in Pose Mode
bpy.ops.pose.reveal()
# Reset rotations of selected bones to their default values
bpy.ops.pose.rot_clear()
# Set the rotation representation used by selected bones
bpy.ops.pose.rotation_mode_set(type='QUATERNION')
# Reset scaling of selected bones to their default values
bpy.ops.pose.scale_clear()
# Toggle selection status of all bones
bpy.ops.pose.select_all(action='TOGGLE')
# Select bones used as targets for the currently selected bones
bpy.ops.pose.select_constraint_target()
# Select all visible bones grouped by similar properties
bpy.ops.pose.select_grouped(extend=False, type='LAYER')
# Select immediate parent/children of selected bones
bpy.ops.pose.select_hierarchy(direction='PARENT', extend=False)
# Select bones related to selected ones by parent/child relationships
bpy.ops.pose.select_linked(extend=False)
# Mirror the bone selection
bpy.ops.pose.select_mirror(only_active=False, extend=False)
# Select bones that are parents of the currently selected bones
bpy.ops.pose.select_parent()
# Reset location, rotation, and scaling of selected bones to their default values
bpy.ops.pose.transforms_clear()
# Reset pose on selected bones to keyframed state
bpy.ops.pose.user_transforms_clear(only_selected=True)
# Apply final constrained position of pose bones to their transform
bpy.ops.pose.visual_transform_apply()

# Make action suitable for use as a Pose Library
bpy.ops.poselib.action_sanitize()
# Apply specified Pose Library pose to the rig
bpy.ops.poselib.apply_pose(pose_index=-1)
# Interactively browse poses in 3D-View
bpy.ops.poselib.browse_interactive(pose_index=-1)
# Add New Pose Library to active Object
bpy.ops.poselib.new()
# Add the current Pose to the active Pose Library
bpy.ops.poselib.pose_add(frame=1, name="Pose")
# Move the pose up or down in the active Pose Library
bpy.ops.poselib.pose_move(pose='<UNKNOWN ENUM>', direction='UP')
# Remove nth pose from the active Pose Library
bpy.ops.poselib.pose_remove(pose='<UNKNOWN ENUM>')
# Rename specified pose from the active Pose Library
bpy.ops.poselib.pose_rename(name="RenamedPose", pose='<UNKNOWN ENUM>')
# Remove Pose Library from active Object
bpy.ops.poselib.unlink()

# Add new cache
bpy.ops.ptcache.add()
# Bake physics
bpy.ops.ptcache.bake(bake=False)
# Bake all physics
bpy.ops.ptcache.bake_all(bake=True)
# Bake from cache
bpy.ops.ptcache.bake_from_cache()
# Free physics bake
bpy.ops.ptcache.free_bake()
# Free all baked caches of all objects in the current scene
bpy.ops.ptcache.free_bake_all()
# Delete current cache
bpy.ops.ptcache.remove()

# Add an Integrator Preset
bpy.ops.render.cycles_integrator_preset_add(name="", remove_active=False)
# Add a Sampling Preset
bpy.ops.render.cycles_sampling_preset_add(name="", remove_active=False)
# OpenGL render active viewport
bpy.ops.render.opengl(animation=False, sequencer=False, write_still=False, view_context=True)
# Play back rendered frames/movies using an external player
bpy.ops.render.play_rendered_anim()
# Add or remove a Render Preset
bpy.ops.render.preset_add(name="", remove_active=False)
# Render active scene
bpy.ops.render.render(animation=False, write_still=False, use_viewport=False, layer="", scene="")
# Set shutter curve
bpy.ops.render.shutter_curve_preset(shape='SMOOTH')
# Cancel show render view
bpy.ops.render.view_cancel()
# Toggle show render view
bpy.ops.render.view_show()

# Bake rigid body transformations of selected objects to keyframes
bpy.ops.rigidbody.bake_to_keyframes(frame_start=1, frame_end=250, step=1)
# Create rigid body constraints between selected rigid bodies
bpy.ops.rigidbody.connect(con_type='FIXED', pivot_type='CENTER', connection_pattern='SELECTED_TO_ACTIVE')
# Add Rigid Body Constraint to active object
bpy.ops.rigidbody.constraint_add(type='FIXED')
# Remove Rigid Body Constraint from Object
bpy.ops.rigidbody.constraint_remove()
# Automatically calculate mass values for Rigid Body Objects based on volume
bpy.ops.rigidbody.mass_calculate(material='Air', density=1)
# Add active object as Rigid Body
bpy.ops.rigidbody.object_add(type='ACTIVE')
# Remove Rigid Body settings from Object
bpy.ops.rigidbody.object_remove()
# Copy Rigid Body settings from active object to selected
bpy.ops.rigidbody.object_settings_copy()
# Add selected objects as Rigid Bodies
bpy.ops.rigidbody.objects_add(type='ACTIVE')
# Remove selected objects from Rigid Body simulation
bpy.ops.rigidbody.objects_remove()
# Change collision shapes for selected Rigid Body Objects
bpy.ops.rigidbody.shape_change(type='MESH')
# Add Rigid Body simulation world to the current scene
bpy.ops.rigidbody.world_add()
# Remove Rigid Body simulation world from the current scene
bpy.ops.rigidbody.world_remove()

# Add or remove a Safe Areas Preset
bpy.ops.safe_areas.preset_add(name="", remove_active=False)

# Delete active scene
bpy.ops.scene.delete()
# Add the data paths to the Freestyle Edge Mark property of selected edges to the active keying set
bpy.ops.scene.freestyle_add_edge_marks_to_keying_set()
# Add the data paths to the Freestyle Face Mark property of selected polygons to the active keying set
bpy.ops.scene.freestyle_add_face_marks_to_keying_set()
# Add an alpha transparency modifier to the line style associated with the active lineset
bpy.ops.scene.freestyle_alpha_modifier_add(type='ALONG_STROKE')
# Add a line color modifier to the line style associated with the active lineset
bpy.ops.scene.freestyle_color_modifier_add(type='ALONG_STROKE')
# Fill the Range Min/Max entries by the min/max distance between selected mesh objects and the source object
bpy.ops.scene.freestyle_fill_range_by_selection(type='COLOR', name="")
# Add a stroke geometry modifier to the line style associated with the active lineset
bpy.ops.scene.freestyle_geometry_modifier_add(type='2D_OFFSET')
# Add a line set into the list of line sets
bpy.ops.scene.freestyle_lineset_add()
# Copy the active line set to a buffer
bpy.ops.scene.freestyle_lineset_copy()
# Change the position of the active line set within the list of line sets
bpy.ops.scene.freestyle_lineset_move(direction='UP')
# Paste the buffer content to the active line set
bpy.ops.scene.freestyle_lineset_paste()
# Remove the active line set from the list of line sets
bpy.ops.scene.freestyle_lineset_remove()
# Create a new line style, reusable by multiple line sets
bpy.ops.scene.freestyle_linestyle_new()
# Duplicate the modifier within the list of modifiers
bpy.ops.scene.freestyle_modifier_copy()
# Move the modifier within the list of modifiers
bpy.ops.scene.freestyle_modifier_move(direction='UP')
# Remove the modifier from the list of modifiers
bpy.ops.scene.freestyle_modifier_remove()
# Add a style module into the list of modules
bpy.ops.scene.freestyle_module_add()
# Change the position of the style module within in the list of style modules
bpy.ops.scene.freestyle_module_move(direction='UP')
# Open a style module file
bpy.ops.scene.freestyle_module_open(filepath="", make_internal=True)
# Remove the style module from the stack
bpy.ops.scene.freestyle_module_remove()
# Create Freestyle stroke material for testing
bpy.ops.scene.freestyle_stroke_material_create()
# Add a line thickness modifier to the line style associated with the active lineset
bpy.ops.scene.freestyle_thickness_modifier_add(type='ALONG_STROKE')
# Add new scene by type
bpy.ops.scene.new(type='NEW')
# Add a render layer
bpy.ops.scene.render_layer_add()
# Remove the selected render layer
bpy.ops.scene.render_layer_remove()
# Add a render view
bpy.ops.scene.render_view_add()
# Remove the selected render view
bpy.ops.scene.render_view_remove()
# Add or remove length units preset
bpy.ops.scene.units_length_preset_add(name="", remove_active=False)

# Handle area action zones for mouse actions/gestures
bpy.ops.screen.actionzone(modifier=0)
# Cancel animation, returning to the original frame
bpy.ops.screen.animation_cancel(restore_frame=True)
# Play animation
bpy.ops.screen.animation_play(reverse=False, sync=False)
# Step through animation by position
bpy.ops.screen.animation_step()
# Duplicate selected area into new window
bpy.ops.screen.area_dupli()
# Join selected areas into new window
bpy.ops.screen.area_join(min_x=-100, min_y=-100, max_x=-100, max_y=-100)
# Move selected area edges
bpy.ops.screen.area_move(x=0, y=0, delta=0)
# Operations for splitting and merging
bpy.ops.screen.area_options()
# Split selected area into new windows
bpy.ops.screen.area_split(direction='HORIZONTAL', factor=0.5, mouse_x=-100, mouse_y=-100)
# Swap selected areas screen positions
bpy.ops.screen.area_swap()
# Revert back to the original screen layout, before fullscreen area overlay
bpy.ops.screen.back_to_previous()
# Delete active screen
bpy.ops.screen.delete()
# Jump to first/last frame in frame range
bpy.ops.screen.frame_jump(end=False)
# Move current frame forward/backward by a given number
bpy.ops.screen.frame_offset(delta=0)
# Toggle header display
bpy.ops.screen.header()
# Toggle the header over/below the main window area
bpy.ops.screen.header_flip()
# Expand or collapse the header pulldown menus
bpy.ops.screen.header_toggle_menus()
# Display header region toolbox
bpy.ops.screen.header_toolbox()
# Jump to previous/next keyframe
bpy.ops.screen.keyframe_jump(next=True)
# Jump to previous/next marker
bpy.ops.screen.marker_jump(next=True)
# Add a new screen
bpy.ops.screen.new()
# Display menu for last action performed
bpy.ops.screen.redo_last()
# Blend in and out overlapping region
bpy.ops.screen.region_blend()
# Toggle the region's alignment (left/right or top/bottom)
bpy.ops.screen.region_flip()
# Split selected area into camera, front, right & top views
bpy.ops.screen.region_quadview()
# Scale selected area
bpy.ops.screen.region_scale()
# Display menu for previous actions performed
bpy.ops.screen.repeat_history(index=0)
# Repeat last action
bpy.ops.screen.repeat_last()
# Toggle display selected area as fullscreen/maximized
bpy.ops.screen.screen_full_area(use_hide_panels=False)
# Cycle through available screens
bpy.ops.screen.screen_set(delta=0)
# Capture a video of the active area or whole Blender window
bpy.ops.screen.screencast(filepath="", full=True)
# Capture a picture of the active area or whole Blender window
bpy.ops.screen.screenshot(filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=True, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, show_multiview=False, use_multiview=False, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', full=True)
# Cycle through the editor context by activating the next/previous one
bpy.ops.screen.space_context_cycle(direction='NEXT')
# Remove unused settings for invisible editors
bpy.ops.screen.spacedata_cleanup()
# Show user preferences
bpy.ops.screen.userpref_show()

# Ignore autoexec warning
bpy.ops.script.autoexec_warn_clear()
# Execute a preset
bpy.ops.script.execute_preset(filepath="", menu_idname="")
# Run Python file
bpy.ops.script.python_file_run(filepath="")
# Reload Scripts
bpy.ops.script.reload()

# Sculpt a stroke into the geometry
bpy.ops.sculpt.brush_stroke(stroke=[], mode='NORMAL', ignore_background_click=False)
# Flood fill the mesh with the selected detail setting
bpy.ops.sculpt.detail_flood_fill()
# Dynamic topology alters the mesh topology while sculpting
bpy.ops.sculpt.dynamic_topology_toggle()
# Recalculate the sculpt BVH to improve performance
bpy.ops.sculpt.optimize()
# Sample the mesh detail on clicked point
bpy.ops.sculpt.sample_detail_size(location=(0, 0))
# Toggle sculpt mode in 3D view
bpy.ops.sculpt.sculptmode_toggle()
# Set the mesh detail (either relative or constant one, depending on current dyntopo mode)
bpy.ops.sculpt.set_detail_size()
# Reset the copy of the mesh that is being sculpted on
bpy.ops.sculpt.set_persistent_base()
# Symmetrize the topology modifications
bpy.ops.sculpt.symmetrize()
# Sculpt UVs using a brush
bpy.ops.sculpt.uv_sculpt_stroke(mode='NORMAL')

#
bpy.ops.sequencer.change_effect_input(swap='A_B')
#
bpy.ops.sequencer.change_effect_type(type='CROSS')
#
bpy.ops.sequencer.change_path(filepath="", directory="", files=[], filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, relative_path=True, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', use_placeholders=False)
#
bpy.ops.sequencer.copy()
# Do cross-fading volume animation of two selected sound strips
bpy.ops.sequencer.crossfade_sounds()
# Cut the selected strips
bpy.ops.sequencer.cut(frame=0, type='SOFT', side='BOTH')
# Cut multi-cam strip and select camera
bpy.ops.sequencer.cut_multicam(camera=1)
# Deinterlace all selected movie sources
bpy.ops.sequencer.deinterlace_selected_movies()
# Erase selected strips from the sequencer
bpy.ops.sequencer.delete()
# Duplicate the selected strips
bpy.ops.sequencer.duplicate(mode='TRANSLATION')
# Duplicate selected strips and move them
bpy.ops.sequencer.duplicate_move(SEQUENCER_OT_duplicate={"mode":'TRANSLATION'}, TRANSFORM_OT_seq_slide={"value":(0, 0), "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "release_confirm":False, "use_accurate":False})
# Add an effect to the sequencer, most are applied on top of existing strips
bpy.ops.sequencer.effect_strip_add(frame_start=0, frame_end=0, channel=1, replace_sel=True, overlap=False, type='CROSS', color=(0, 0, 0))
# Enable selected proxies on all selected Movie strips
bpy.ops.sequencer.enable_proxies(proxy_25=False, proxy_50=False, proxy_75=False, proxy_100=False, overwrite=False)
# Export .srt file containing text strips
bpy.ops.sequencer.export_subtitles(filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=8, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA')
# Insert gap at current frame to first strips at the right, independent of selection or locked state of strips
bpy.ops.sequencer.gap_insert(frames=10)
# Remove gap at current frame to first strip at the right, independent of selection or locked state of strips
bpy.ops.sequencer.gap_remove(all=False)
# Add an image or image sequence to the sequencer
bpy.ops.sequencer.image_strip_add(directory="", files=[], filter_blender=False, filter_backup=False, filter_image=True, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, relative_path=True, show_multiview=False, use_multiview=False, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', frame_start=0, frame_end=0, channel=1, replace_sel=True, overlap=False, use_placeholders=False)
# On image sequence strips, it returns a strip for each image
bpy.ops.sequencer.images_separate(length=1)
# Lock the active strip so that it can't be transformed
bpy.ops.sequencer.lock()
# Add a mask strip to the sequencer
bpy.ops.sequencer.mask_strip_add(frame_start=0, channel=1, replace_sel=True, overlap=False, mask='<UNKNOWN ENUM>')
# Group selected strips into a metastrip
bpy.ops.sequencer.meta_make()
# Put the contents of a metastrip back in the sequencer
bpy.ops.sequencer.meta_separate()
# Toggle a metastrip (to edit enclosed strips)
bpy.ops.sequencer.meta_toggle()
# Add a movie strip to the sequencer
bpy.ops.sequencer.movie_strip_add(filepath="", files=[], filter_blender=False, filter_backup=False, filter_image=False, filter_movie=True, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, relative_path=True, show_multiview=False, use_multiview=False, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', frame_start=0, channel=1, replace_sel=True, overlap=False, sound=True, use_framerate=True)
# Add a movieclip strip to the sequencer
bpy.ops.sequencer.movieclip_strip_add(frame_start=0, channel=1, replace_sel=True, overlap=False, clip='<UNKNOWN ENUM>')
# Mute (un)selected strips
bpy.ops.sequencer.mute(unselected=False)
# Clear strip offsets from the start and end frames
bpy.ops.sequencer.offset_clear()
#
bpy.ops.sequencer.paste()
# Toggle the properties region visibility
bpy.ops.sequencer.properties()
# Reassign the inputs for the effect strip
bpy.ops.sequencer.reassign_inputs()
# Rebuild all selected proxies and timecode indices using the job system
bpy.ops.sequencer.rebuild_proxy()
# Refresh the sequencer editor
bpy.ops.sequencer.refresh_all()
# Reload strips in the sequencer
bpy.ops.sequencer.reload(adjust_length=False)
# Set render size and aspect from active sequence
bpy.ops.sequencer.rendersize()
# Use mouse to sample color in current frame
bpy.ops.sequencer.sample()
# Add a strip to the sequencer using a blender scene as a source
bpy.ops.sequencer.scene_strip_add(frame_start=0, channel=1, replace_sel=True, overlap=False, scene='Scene')
# Select a strip (last selected becomes the "active strip")
bpy.ops.sequencer.select(extend=False, linked_handle=False, left_right='NONE', linked_time=False)
# Select strips on the nominated side of the active strip
bpy.ops.sequencer.select_active_side(side='BOTH')
# Select or deselect all strips
bpy.ops.sequencer.select_all(action='TOGGLE')
# Select strips using border selection
bpy.ops.sequencer.select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
# Select all strips grouped by various properties
bpy.ops.sequencer.select_grouped(type='TYPE', extend=False, use_active_channel=False)
# Select manipulator handles on the sides of the selected strip
bpy.ops.sequencer.select_handles(side='BOTH')
# Shrink the current selection of adjacent selected strips
bpy.ops.sequencer.select_less()
# Select all strips adjacent to the current selection
bpy.ops.sequencer.select_linked()
# Select a chain of linked strips nearest to the mouse pointer
bpy.ops.sequencer.select_linked_pick(extend=False)
# Select more strips adjacent to the current selection
bpy.ops.sequencer.select_more()
# Trim the contents of the active strip
bpy.ops.sequencer.slip(offset=0)
# Frame where selected strips will be snapped
bpy.ops.sequencer.snap(frame=0)
# Add a sound strip to the sequencer
bpy.ops.sequencer.sound_strip_add(filepath="", files=[], filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=True, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, relative_path=True, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', frame_start=0, channel=1, replace_sel=True, overlap=False, cache=False, mono=False)
# Move frame to previous edit point
bpy.ops.sequencer.strip_jump(next=True, center=True)
# Add a modifier to the strip
bpy.ops.sequencer.strip_modifier_add(type='COLOR_BALANCE')
# Copy modifiers of the active strip to all selected strips
bpy.ops.sequencer.strip_modifier_copy(type='REPLACE')
# Move modifier up and down in the stack
bpy.ops.sequencer.strip_modifier_move(name="Name", direction='UP')
# Remove a modifier from the strip
bpy.ops.sequencer.strip_modifier_remove(name="Name")
# Swap active strip with strip to the right or left
bpy.ops.sequencer.swap(side='RIGHT')
# Swap 2 sequencer strips
bpy.ops.sequencer.swap_data()
# Swap the first two inputs for the effect strip
bpy.ops.sequencer.swap_inputs()
# Unlock the active strip so that it can't be transformed
bpy.ops.sequencer.unlock()
# Unmute (un)selected strips
bpy.ops.sequencer.unmute(unselected=False)
# View all the strips in the sequencer
bpy.ops.sequencer.view_all()
# Zoom preview to fit in the area
bpy.ops.sequencer.view_all_preview()
# Reset viewable area to show range around current frame
bpy.ops.sequencer.view_frame()
# Set the boundaries of the border used for offset-view
bpy.ops.sequencer.view_ghost_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0)
# Zoom the sequencer on the selected strips
bpy.ops.sequencer.view_selected()
# Toggle between sequencer views (sequence, preview, both)
bpy.ops.sequencer.view_toggle()
# Change zoom ratio of sequencer preview
bpy.ops.sequencer.view_zoom_ratio(ratio=1)

# Cancel the current sketch stroke
bpy.ops.sketch.cancel_stroke()
# Convert the selected sketch strokes to bone chains
bpy.ops.sketch.convert()
# Delete a sketch stroke
bpy.ops.sketch.delete()
# Draw preview of current sketch stroke (internal use)
bpy.ops.sketch.draw_preview(snap=False)
# Start to draw a sketch stroke
bpy.ops.sketch.draw_stroke(snap=False)
# End and keep the current sketch stroke
bpy.ops.sketch.finish_stroke()
# Start to draw a gesture stroke
bpy.ops.sketch.gesture(snap=False)
# Select a sketch stroke
bpy.ops.sketch.select()

# Update the audio animation cache
bpy.ops.sound.bake_animation()
# Mix the scene's audio to a sound file
bpy.ops.sound.mixdown(filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=True, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, relative_path=True, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', accuracy=1024, container='FLAC', codec='FLAC', format='S16', bitrate=192, split_channels=False)
# Load a sound file
bpy.ops.sound.open(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=True, filter_python=False, filter_font=False, filter_sound=True, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, relative_path=True, show_multiview=False, use_multiview=False, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', cache=False, mono=False)
# Load a sound file as mono
bpy.ops.sound.open_mono(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=True, filter_python=False, filter_font=False, filter_sound=True, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, relative_path=True, show_multiview=False, use_multiview=False, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', cache=False, mono=True)
# Pack the sound into the current blend file
bpy.ops.sound.pack()
# Unpack the sound to the samples filename
bpy.ops.sound.unpack(method='USE_LOCAL', id="")
# Update animation flags
bpy.ops.sound.update_animation_flags()

# Construct a Nurbs surface Circle
bpy.ops.surface.primitive_nurbs_surface_circle_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Construct a Nurbs surface Curve
bpy.ops.surface.primitive_nurbs_surface_curve_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Construct a Nurbs surface Cylinder
bpy.ops.surface.primitive_nurbs_surface_cylinder_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Construct a Nurbs surface Sphere
bpy.ops.surface.primitive_nurbs_surface_sphere_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Construct a Nurbs surface Patch
bpy.ops.surface.primitive_nurbs_surface_surface_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
# Construct a Nurbs surface Torus
bpy.ops.surface.primitive_nurbs_surface_torus_add(radius=1, view_align=False, enter_editmode=False, location=(0, 0, 0), rotation=(0, 0, 0), layers=(False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))

# Show a list of used text in the open document
bpy.ops.text.autocomplete()
# Convert selected text to comment
bpy.ops.text.comment()
# Convert whitespaces by type
bpy.ops.text.convert_whitespace(type='SPACES')
# Copy selected text to clipboard
bpy.ops.text.copy()
# Set cursor position
bpy.ops.text.cursor_set(x=0, y=0)
# Cut selected text to clipboard
bpy.ops.text.cut()
# Delete text by cursor position
bpy.ops.text.delete(type='NEXT_CHARACTER')
# Duplicate the current line
bpy.ops.text.duplicate_line()
# Find specified text
bpy.ops.text.find()
# Find specified text and set as selected
bpy.ops.text.find_set_selected()
# Indent selected text
bpy.ops.text.indent()
# Insert text at cursor position
bpy.ops.text.insert(text="")
# Jump cursor to line
bpy.ops.text.jump(line=1)
# Insert line break at cursor position
bpy.ops.text.line_break()
# The current line number
bpy.ops.text.line_number()
# Make active text file internal
bpy.ops.text.make_internal()
# Move cursor to position type
bpy.ops.text.move(type='LINE_BEGIN')
# Move the currently selected line(s) up/down
bpy.ops.text.move_lines(direction='DOWN')
# Move the cursor while selecting
bpy.ops.text.move_select(type='LINE_BEGIN')
# Create a new text data-block
bpy.ops.text.new()
# Open a new text data-block
bpy.ops.text.open(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=True, filter_font=False, filter_sound=False, filter_text=True, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', internal=False)
# Toggle overwrite while typing
bpy.ops.text.overwrite_toggle()
# Paste text from clipboard
bpy.ops.text.paste(selection=False)
# Toggle the properties region visibility
bpy.ops.text.properties()
# Refresh all pyconstraints
bpy.ops.text.refresh_pyconstraints()
# Reload active text data-block from its file
bpy.ops.text.reload()
# Replace text with the specified text
bpy.ops.text.replace()
# Replace text with specified text and set as selected
bpy.ops.text.replace_set_selected()
# When external text is out of sync, resolve the conflict
bpy.ops.text.resolve_conflict(resolution='IGNORE')
# Run active script
bpy.ops.text.run_script()
# Save active text data-block
bpy.ops.text.save()
# Save active text file with options
bpy.ops.text.save_as(filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=True, filter_font=False, filter_sound=False, filter_text=True, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA')
#
bpy.ops.text.scroll(lines=1)
#
bpy.ops.text.scroll_bar(lines=1)
# Select all text
bpy.ops.text.select_all()
# Select text by line
bpy.ops.text.select_line()
# Select word under cursor
bpy.ops.text.select_word()
# Set cursor selection
bpy.ops.text.selection_set(select=False)
# Start searching text
bpy.ops.text.start_find()
# Create 3D text object from active text data-block
bpy.ops.text.to_3d_object(split_lines=False)
# Convert selected comment to text
bpy.ops.text.uncomment()
# Unindent selected text
bpy.ops.text.unindent()
# Unlink active text data-block
bpy.ops.text.unlink()

# Discard the environment map and free it from memory
bpy.ops.texture.envmap_clear()
# Discard all environment maps in the .blend file and free them from memory
bpy.ops.texture.envmap_clear_all()
# Save the current generated Environment map to an image file
bpy.ops.texture.envmap_save(layout=(0, 0, 1, 0, 2, 0, 0, 1, 1, 1, 2, 1), filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=True, filter_movie=True, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, show_multiview=False, use_multiview=False, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA')
# Add a new texture
bpy.ops.texture.new()
# Copy the material texture settings and nodes
bpy.ops.texture.slot_copy()
# Move texture slots up and down
bpy.ops.texture.slot_move(type='UP')
# Copy the texture settings and nodes
bpy.ops.texture.slot_paste()

# Set the end frame
bpy.ops.time.end_frame_set()
# Set the start frame
bpy.ops.time.start_frame_set()
# Show the entire playable frame range
bpy.ops.time.view_all()
# Reset viewable area to show range around current frame
bpy.ops.time.view_frame()

# Bend selected items between the 3D cursor and the mouse
bpy.ops.transform.bend(value=(0,), mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), gpencil_strokes=False, release_confirm=False, use_accurate=False)
# Create transformation orientation from selection
bpy.ops.transform.create_orientation(name="", use_view=False, use=False, overwrite=False)
# Delete transformation orientation
bpy.ops.transform.delete_orientation()
# Change the bevel weight of edges
bpy.ops.transform.edge_bevelweight(value=0, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False, use_accurate=False)
# Change the crease of edges
bpy.ops.transform.edge_crease(value=0, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False, use_accurate=False)
# Slide an edge loop along a mesh
bpy.ops.transform.edge_slide(value=0, single_side=False, use_even=False, flipped=False, use_clamp=True, mirror=False, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), correct_uv=False, release_confirm=False, use_accurate=False)
# Mirror selected items around one or more axes
bpy.ops.transform.mirror(constraint_axis=(False, False, False), constraint_orientation='GLOBAL', proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, gpencil_strokes=False, release_confirm=False, use_accurate=False)
# Push/Pull selected items
bpy.ops.transform.push_pull(value=0, mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False, use_accurate=False)
# Scale (resize) selected items
bpy.ops.transform.resize(value=(1, 1, 1), constraint_axis=(False, False, False), constraint_orientation='GLOBAL', mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), gpencil_strokes=False, texture_space=False, remove_on_cancel=False, release_confirm=False, use_accurate=False)
# Rotate selected items
bpy.ops.transform.rotate(value=0, axis=(0, 0, 0), constraint_axis=(False, False, False), constraint_orientation='GLOBAL', mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), gpencil_strokes=False, release_confirm=False, use_accurate=False)
# Select transformation orientation
bpy.ops.transform.select_orientation(orientation='GLOBAL')
# Slide a sequence strip in time
bpy.ops.transform.seq_slide(value=(0, 0), snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False, use_accurate=False)
# Shear selected items along the horizontal screen axis
bpy.ops.transform.shear(value=0, mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), gpencil_strokes=False, release_confirm=False, use_accurate=False)
# Shrink/fatten selected vertices along normals
bpy.ops.transform.shrink_fatten(value=0, use_even_offset=True, mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False, use_accurate=False)
# Scale selected vertices' skin radii
bpy.ops.transform.skin_resize(value=(1, 1, 1), constraint_axis=(False, False, False), constraint_orientation='GLOBAL', mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False, use_accurate=False)
# Tilt selected control vertices of 3D curve
bpy.ops.transform.tilt(value=0, mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), release_confirm=False, use_accurate=False)
# Move selected vertices outward in a spherical shape around mesh center
bpy.ops.transform.tosphere(value=0, mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), gpencil_strokes=False, release_confirm=False, use_accurate=False)
# Trackball style rotation of selected items
bpy.ops.transform.trackball(value=(0, 0), mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), gpencil_strokes=False, release_confirm=False, use_accurate=False)
# Transform selected items by mode type
bpy.ops.transform.transform(mode='TRANSLATION', value=(0, 0, 0, 0), axis=(0, 0, 0), constraint_axis=(False, False, False), constraint_orientation='GLOBAL', mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), gpencil_strokes=False, release_confirm=False, use_accurate=False)
# Translate (move) selected items
bpy.ops.transform.translate(value=(0, 0, 0), constraint_axis=(False, False, False), constraint_orientation='GLOBAL', mirror=False, proportional='DISABLED', proportional_edit_falloff='SMOOTH', proportional_size=1, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), gpencil_strokes=False, texture_space=False, remove_on_cancel=False, release_confirm=False, use_accurate=False)
# Slide a vertex along a mesh
bpy.ops.transform.vert_slide(value=0, use_even=False, flipped=False, use_clamp=True, mirror=False, snap=False, snap_target='CLOSEST', snap_point=(0, 0, 0), snap_align=False, snap_normal=(0, 0, 0), correct_uv=False, release_confirm=False, use_accurate=False)
# Randomize vertices
bpy.ops.transform.vertex_random(offset=0.1, uniform=0, normal=0, seed=0)
# Warp vertices around the cursor
bpy.ops.transform.vertex_warp(warp_angle=6.28319, offset_angle=0, min=-1, max=1, viewmat=(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), center=(0, 0, 0))

# Copy the RNA data path for this property to the clipboard
bpy.ops.ui.copy_data_path_button(full_path=False)
# Copy the Python command matching this button
bpy.ops.ui.copy_python_command_button()
# Copy property from this object to selected objects or bones
bpy.ops.ui.copy_to_selected_button(all=True)
# Drop colors to buttons
bpy.ops.ui.drop_color(color=(0, 0, 0), gamma=False)
# Edit UI source code of the active button
bpy.ops.ui.editsource()
# Edit i18n in current language for the active button
bpy.ops.ui.edittranslation_init()
# Sample a color from the Blender Window to store in a property
bpy.ops.ui.eyedropper_color()
# Sample depth from the 3D view
bpy.ops.ui.eyedropper_depth()
# Pick a property to use as a driver target
bpy.ops.ui.eyedropper_driver(mapping_type='SINGLE_MANY')
# Sample a data-block from the 3D View to store in a property
bpy.ops.ui.eyedropper_id()
# Force a full reload of UI translation
bpy.ops.ui.reloadtranslation()
# Write the reports
bpy.ops.ui.reports_to_textblock()
# Reset this property's value to its default value
bpy.ops.ui.reset_default_button(all=True)
# Reset to the default theme colors
bpy.ops.ui.reset_default_theme()
# Clear the property and use default or generated value in operators
bpy.ops.ui.unset_property_button()

# Align selected UV vertices to an axis
bpy.ops.uv.align(axis='ALIGN_AUTO')
# Average the size of separate UV islands, based on their area in 3D space
bpy.ops.uv.average_islands_scale()
# Select UV vertices using circle selection
bpy.ops.uv.circle_select(x=0, y=0, radius=1, gesture_mode=0)
# Project the UV vertices of the mesh over the six faces of a cube
bpy.ops.uv.cube_project(cube_size=1, correct_aspect=True, clip_to_bounds=False, scale_to_bounds=False)
# Set 2D cursor location
bpy.ops.uv.cursor_set(location=(0, 0))
# Project the UV vertices of the mesh over the curved wall of a cylinder
bpy.ops.uv.cylinder_project(direction='VIEW_ON_EQUATOR', align='POLAR_ZX', radius=1, correct_aspect=True, clip_to_bounds=False, scale_to_bounds=False)
# Export UV layout to file
bpy.ops.uv.export_layout(filepath="", check_existing=True, export_all=False, modified=False, mode='PNG', size=(1024, 1024), opacity=0.25, tessellated=False)
# Follow UVs from active quads along continuous face loops
bpy.ops.uv.follow_active_quads(mode='LENGTH_AVERAGE')
# Hide (un)selected UV vertices
bpy.ops.uv.hide(unselected=False)
# Pack each faces UV's into the UV bounds
bpy.ops.uv.lightmap_pack(PREF_CONTEXT='SEL_FACES', PREF_PACK_IN_ONE=True, PREF_NEW_UVLAYER=False, PREF_APPLY_IMAGE=False, PREF_IMG_PX_SIZE=512, PREF_BOX_DIV=12, PREF_MARGIN_DIV=0.1)
# Mark selected UV edges as seams
bpy.ops.uv.mark_seam(clear=False)
# Reduce UV stretching by relaxing angles
bpy.ops.uv.minimize_stretch(fill_holes=True, blend=0, iterations=0)
# Transform all islands so that they fill up the UV space as much as possible
bpy.ops.uv.pack_islands(rotate=True, margin=0.001)
# Set/clear selected UV vertices as anchored between multiple unwrap operations
bpy.ops.uv.pin(clear=False)
# Project the UV vertices of the mesh as seen in current 3D view
bpy.ops.uv.project_from_view(orthographic=False, camera_bounds=True, correct_aspect=True, clip_to_bounds=False, scale_to_bounds=False)
# Selected UV vertices that are within a radius of each other are welded together
bpy.ops.uv.remove_doubles(threshold=0.02, use_unselected=False)
# Reset UV projection
bpy.ops.uv.reset()
# Reveal all hidden UV vertices
bpy.ops.uv.reveal()
# Set mesh seams according to island setup in the UV editor
bpy.ops.uv.seams_from_islands(mark_seams=True, mark_sharp=False)
# Select UV vertices
bpy.ops.uv.select(extend=False, location=(0, 0))
# Change selection of all UV vertices
bpy.ops.uv.select_all(action='TOGGLE')
# Select UV vertices using border selection
bpy.ops.uv.select_border(pinned=False, gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
# Select UVs using lasso selection
bpy.ops.uv.select_lasso(path=[], deselect=False, extend=True)
# Deselect UV vertices at the boundary of each selection region
bpy.ops.uv.select_less()
# Select all UV vertices linked to the active UV map
bpy.ops.uv.select_linked(extend=False)
# Select all UV vertices linked under the mouse
bpy.ops.uv.select_linked_pick(extend=False, location=(0, 0))
# Select a loop of connected UV vertices
bpy.ops.uv.select_loop(extend=False, location=(0, 0))
# Select more UV vertices connected to initial selection
bpy.ops.uv.select_more()
# Select all pinned UV vertices
bpy.ops.uv.select_pinned()
# Select only entirely selected faces
bpy.ops.uv.select_split()
# This script projection unwraps the selected faces of a mesh (it operates on all selected mesh objects, and can be used to unwrap selected faces, or all faces)
bpy.ops.uv.smart_project(angle_limit=66, island_margin=0, user_area_weight=0, use_aspect=True, stretch_to_bounds=True)
# Snap cursor to target type
bpy.ops.uv.snap_cursor(target='PIXELS')
# Snap selected UV vertices to target type
bpy.ops.uv.snap_selected(target='PIXELS')
# Project the UV vertices of the mesh over the curved surface of a sphere
bpy.ops.uv.sphere_project(direction='VIEW_ON_EQUATOR', align='POLAR_ZX', correct_aspect=True, clip_to_bounds=False, scale_to_bounds=False)
# Stitch selected UV vertices by proximity
bpy.ops.uv.stitch(use_limit=False, snap_islands=True, limit=0.01, static_island=0, midpoint_snap=False, clear_seams=True, mode='VERTEX', stored_mode='VERTEX', selection=[])
# Set UV image tile coordinates
bpy.ops.uv.tile_set(tile=(0, 0))
# Unwrap the mesh of the object being edited
bpy.ops.uv.unwrap(method='ANGLE_BASED', fill_holes=True, correct_aspect=True, use_subsurf_data=False, margin=0.001)
# Weld selected UV vertices together
bpy.ops.uv.weld()

# Use a 3D mouse device to pan/zoom the view
bpy.ops.view2d.ndof()
# Pan the view
bpy.ops.view2d.pan(deltax=0, deltay=0)
# Reset the view
bpy.ops.view2d.reset()
# Scroll the view down
bpy.ops.view2d.scroll_down(deltax=0, deltay=0, page=False)
# Scroll the view left
bpy.ops.view2d.scroll_left(deltax=0, deltay=0)
# Scroll the view right
bpy.ops.view2d.scroll_right(deltax=0, deltay=0)
# Scroll the view up
bpy.ops.view2d.scroll_up(deltax=0, deltay=0, page=False)
# Scroll view by mouse click and drag
bpy.ops.view2d.scroller_activate()
#
bpy.ops.view2d.smoothview(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0)
# Zoom in/out the view
bpy.ops.view2d.zoom(deltax=0, deltay=0)
# Zoom in the view to the nearest item contained in the border
bpy.ops.view2d.zoom_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0)
# Zoom in the view
bpy.ops.view2d.zoom_in(zoomfacx=0, zoomfacy=0)
# Zoom out the view
bpy.ops.view2d.zoom_out(zoomfacx=0, zoomfacy=0)

# Add a new background image (Ctrl for Empty Object)
bpy.ops.view3d.background_image_add(name="Image", filepath="", filter_blender=False, filter_backup=False, filter_image=True, filter_movie=True, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=9, relative_path=True, show_multiview=False, use_multiview=False, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA')
# Remove a background image from the 3D view
bpy.ops.view3d.background_image_remove(index=0)
# Set camera view to active view
bpy.ops.view3d.camera_to_view()
# Move the camera so selected objects are framed
bpy.ops.view3d.camera_to_view_selected()
# Clear the boundaries of the border render and disable border render
bpy.ops.view3d.clear_render_border()
# Set the view clipping border
bpy.ops.view3d.clip_border(xmin=0, xmax=0, ymin=0, ymax=0)
# Selected objects are saved in a temp file
bpy.ops.view3d.copybuffer()
# Set the location of the 3D cursor
bpy.ops.view3d.cursor3d()
# Dolly in/out in the view
bpy.ops.view3d.dolly(delta=0, mx=0, my=0)
# Extrude individual elements and move
bpy.ops.view3d.edit_mesh_extrude_individual_move()
# Extrude and move along normals
bpy.ops.view3d.edit_mesh_extrude_move_normal()
# Extrude and move along individual normals
bpy.ops.view3d.edit_mesh_extrude_move_shrink_fatten()
# Enable the transform manipulator for use
bpy.ops.view3d.enable_manipulator(translate=False, rotate=False, scale=False)
# Interactively fly around the scene
bpy.ops.view3d.fly()
# Start game engine
bpy.ops.view3d.game_start()
# Toggle layer(s) visibility
bpy.ops.view3d.layers(nr=1, extend=False, toggle=True)
# Toggle display of selected object(s) separately and centered in view
bpy.ops.view3d.localview()
# Manipulate selected item by axis
bpy.ops.view3d.manipulator(constraint_axis=(False, False, False), constraint_orientation='GLOBAL', release_confirm=False, use_accurate=False, use_planar_constraint=False)
# Move the view
bpy.ops.view3d.move()
# Interactively navigate around the scene (uses the mode (walk/fly) preference)
bpy.ops.view3d.navigate()
# Pan and rotate the view with the 3D mouse
bpy.ops.view3d.ndof_all()
# Orbit the view using the 3D mouse
bpy.ops.view3d.ndof_orbit()
# Orbit and zoom the view using the 3D mouse
bpy.ops.view3d.ndof_orbit_zoom()
# Pan the view with the 3D mouse
bpy.ops.view3d.ndof_pan()
# Set the active object as the active camera for this view or scene
bpy.ops.view3d.object_as_camera()
# Contents of copy buffer gets pasted
bpy.ops.view3d.pastebuffer(autoselect=True, active_layer=True)
# Toggle the properties region visibility
bpy.ops.view3d.properties()
# Set the boundaries of the border render and enable border render
bpy.ops.view3d.render_border(xmin=0, xmax=0, ymin=0, ymax=0, camera_only=False)
# Rotate the view
bpy.ops.view3d.rotate()
# Interactive ruler
bpy.ops.view3d.ruler()
# Activate/select item(s)
bpy.ops.view3d.select(extend=False, deselect=False, toggle=False, center=False, enumerate=False, object=False, location=(0, 0))
# Select items using border selection
bpy.ops.view3d.select_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0, extend=True)
# Select items using circle selection
bpy.ops.view3d.select_circle(x=0, y=0, radius=1, gesture_mode=0)
# Select items using lasso selection
bpy.ops.view3d.select_lasso(path=[], deselect=False, extend=True)
# Menu object selection
bpy.ops.view3d.select_menu(name='<UNKNOWN ENUM>', toggle=False)
# Select element under the mouse, deselect everything is there's nothing under the mouse
bpy.ops.view3d.select_or_deselect_all(extend=False, toggle=False, deselect=False, center=False, enumerate=False, object=False)
#
bpy.ops.view3d.smoothview()
# Snap cursor to active item
bpy.ops.view3d.snap_cursor_to_active()
# Snap cursor to the Center
bpy.ops.view3d.snap_cursor_to_center()
# Snap cursor to nearest grid division
bpy.ops.view3d.snap_cursor_to_grid()
# Snap cursor to center of selected item(s)
bpy.ops.view3d.snap_cursor_to_selected()
# Snap selected item(s) to the active item
bpy.ops.view3d.snap_selected_to_active()
# Snap selected item(s) to cursor
bpy.ops.view3d.snap_selected_to_cursor(use_offset=True)
# Snap selected item(s) to nearest grid division
bpy.ops.view3d.snap_selected_to_grid()
# Toggle rendered shading mode of the viewport
bpy.ops.view3d.toggle_render()
# Toggles tool shelf display
bpy.ops.view3d.toolshelf()
# View all objects in scene
bpy.ops.view3d.view_all(use_all_regions=False, center=False)
# Center the camera view
bpy.ops.view3d.view_center_camera()
# Center the view so that the cursor is in the middle of the view
bpy.ops.view3d.view_center_cursor()
# Center the view lock offset
bpy.ops.view3d.view_center_lock()
# Center the view to the Z-depth position under the mouse cursor
bpy.ops.view3d.view_center_pick()
# Clear all view locking
bpy.ops.view3d.view_lock_clear()
# Lock the view to the active object/bone
bpy.ops.view3d.view_lock_to_active()
# Orbit the view
bpy.ops.view3d.view_orbit(angle=0, type='ORBITLEFT')
# Pan the view
bpy.ops.view3d.view_pan(type='PANLEFT')
# Switch the current view from perspective/orthographic projection
bpy.ops.view3d.view_persportho()
# Roll the view
bpy.ops.view3d.view_roll(angle=0, type='ANGLE')
# Move the view to the selection center
bpy.ops.view3d.view_selected(use_all_regions=False)
# Use a preset viewpoint
bpy.ops.view3d.viewnumpad(type='LEFT', align_active=False)
# Interactively walk around the scene
bpy.ops.view3d.walk()
# Zoom in/out in the view
bpy.ops.view3d.zoom(delta=0, mx=0, my=0)
# Zoom in the view to the nearest object contained in the border
bpy.ops.view3d.zoom_border(gesture_mode=0, xmin=0, xmax=0, ymin=0, ymax=0)
# Match the camera to 1:1 to the render output
bpy.ops.view3d.zoom_camera_1_to_1()

# Disable an add-on
bpy.ops.wm.addon_disable(module="")
# Enable an add-on
bpy.ops.wm.addon_enable(module="")
# Display information and preferences for this add-on
bpy.ops.wm.addon_expand(module="")
# Install an add-on
bpy.ops.wm.addon_install(overwrite=True, target='DEFAULT', filepath="", filter_folder=True, filter_python=True, filter_glob="*.py;*.zip")
# Scan add-on directories for new modules
bpy.ops.wm.addon_refresh()
# Delete the add-on from the file system
bpy.ops.wm.addon_remove(module="")
# Show add-on user preferences
bpy.ops.wm.addon_userpref_show(module="")
# Export current scene in an Alembic archive
bpy.ops.wm.alembic_export(filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=True, filter_folder=True, filter_blenlib=False, filemode=8, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', start=-2147483648, end=-2147483648, xsamples=1, gsamples=1, sh_open=0, sh_close=1, selected=False, renderable_only=True, visible_layers_only=False, flatten=False, uvs=True, packuv=True, normals=True, vcolors=False, face_sets=False, subdiv_schema=False, apply_subdiv=False, compression_type='OGAWA', global_scale=1, triangulate=False, quad_method='SHORTEST_DIAGONAL', ngon_method='BEAUTY', export_hair=True, export_particles=True, as_background_job=True, init_scene_frame_range=False)
# Load an Alembic archive
bpy.ops.wm.alembic_import(filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=True, filter_folder=True, filter_blenlib=False, filemode=8, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', scale=1, set_frame_range=True, validate_meshes=False, is_sequence=False, as_background_job=True)
# Install an application-template
bpy.ops.wm.app_template_install(overwrite=True, filepath="", filter_folder=True, filter_glob="*.zip")
#
bpy.ops.wm.appconfig_activate(filepath="")
#
bpy.ops.wm.appconfig_default()
# Append from a Library .blend file
bpy.ops.wm.append(filepath="", directory="", filename="", files=[], filter_blender=True, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=True, filemode=1, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', link=False, autoselect=True, active_layer=True, instance_groups=False, set_fake=False, use_recursive=True)
# Launch the blender-player with the current blend-file
bpy.ops.wm.blenderplayer_start()
# Call (draw) a pre-defined menu
bpy.ops.wm.call_menu(name="")
# Call (draw) a pre-defined pie menu
bpy.ops.wm.call_menu_pie(name="")
# Save a Collada file
bpy.ops.wm.collada_export(filepath="", check_existing=True, filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=True, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=8, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', apply_modifiers=False, export_mesh_type=0, export_mesh_type_selection='view', selected=False, include_children=False, include_armatures=False, include_shapekeys=True, deform_bones_only=False, active_uv_only=False, use_texture_copies=True, triangulate=True, use_object_instantiation=True, use_blender_profile=True, sort_by_name=False, export_transformation_type=0, export_transformation_type_selection='matrix', export_texture_type=0, export_texture_type_selection='mat', open_sim=False, limit_precision=False, keep_bind_info=False)
# Load a Collada file
bpy.ops.wm.collada_import(filepath="", filter_blender=False, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=True, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=8, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', import_units=False, fix_orientation=False, find_chains=False, auto_connect=False, min_chain_length=0, keep_bind_info=False)
# Toggle System Console
bpy.ops.wm.console_toggle()
# Set boolean values for a collection of items
bpy.ops.wm.context_collection_boolean_set(data_path_iter="", data_path_item="", type='TOGGLE')
# Set a context array value (useful for cycling the active mesh edit mode)
bpy.ops.wm.context_cycle_array(data_path="", reverse=False)
# Toggle a context value
bpy.ops.wm.context_cycle_enum(data_path="", reverse=False, wrap=False)
# Set a context value (useful for cycling active material, vertex keys, groups, etc.)
bpy.ops.wm.context_cycle_int(data_path="", reverse=False, wrap=False)
#
bpy.ops.wm.context_menu_enum(data_path="")
# Adjust arbitrary values with mouse input
bpy.ops.wm.context_modal_mouse(data_path_iter="", data_path_item="", header_text="", input_scale=0.01, invert=False, initial_x=0)
#
bpy.ops.wm.context_pie_enum(data_path="")
# Scale a float context value
bpy.ops.wm.context_scale_float(data_path="", value=1)
# Scale an int context value
bpy.ops.wm.context_scale_int(data_path="", value=1, always_step=True)
# Set a context value
bpy.ops.wm.context_set_boolean(data_path="", value=True)
# Set a context value
bpy.ops.wm.context_set_enum(data_path="", value="")
# Set a context value
bpy.ops.wm.context_set_float(data_path="", value=0, relative=False)
# Set a context value to an ID data-block
bpy.ops.wm.context_set_id(data_path="", value="")
# Set a context value
bpy.ops.wm.context_set_int(data_path="", value=0, relative=False)
# Set a context value
bpy.ops.wm.context_set_string(data_path="", value="")
# Set a context value
bpy.ops.wm.context_set_value(data_path="", value="")
# Toggle a context value
bpy.ops.wm.context_toggle(data_path="")
# Toggle a context value
bpy.ops.wm.context_toggle_enum(data_path="", value_1="", value_2="")
# Copy settings from previous version
bpy.ops.wm.copy_prev_settings()
# Open a popup to set the debug level
bpy.ops.wm.debug_menu(debug_value=0)
# Print dependency graph relations to the console
bpy.ops.wm.dependency_relations()
# Load online reference docs
bpy.ops.wm.doc_view(doc_id="")
# Load online manual
bpy.ops.wm.doc_view_manual(doc_id="")
# View a context based online manual in a web browser
bpy.ops.wm.doc_view_manual_ui_context()
# Add or remove an Application Interaction Preset
bpy.ops.wm.interaction_preset_add(name="", remove_active=False)
# Add or remove a theme preset
bpy.ops.wm.interface_theme_preset_add(name="", remove_active=False)
#
bpy.ops.wm.keyconfig_activate(filepath="")
# Export key configuration to a python script
bpy.ops.wm.keyconfig_export(filepath="keymap.py", filter_folder=True, filter_text=True, filter_python=True)
# Import key configuration from a python script
bpy.ops.wm.keyconfig_import(filepath="keymap.py", filter_folder=True, filter_text=True, filter_python=True, keep_original=True)
# Add or remove a Key-config Preset
bpy.ops.wm.keyconfig_preset_add(name="", remove_active=False)
# Remove key config
bpy.ops.wm.keyconfig_remove()
# Test key-config for conflicts
bpy.ops.wm.keyconfig_test()
# Add key map item
bpy.ops.wm.keyitem_add()
# Remove key map item
bpy.ops.wm.keyitem_remove(item_id=0)
# Restore key map item
bpy.ops.wm.keyitem_restore(item_id=0)
# Restore key map(s)
bpy.ops.wm.keymap_restore(all=False)
# Reload the given library
bpy.ops.wm.lib_reload(library="", filepath="", directory="", filename="", filter_blender=True, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=8, relative_path=True, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA')
# Relocate the given library to one or several others
bpy.ops.wm.lib_relocate(library="", filepath="", directory="", filename="", files=[], filter_blender=True, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=8, relative_path=True, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA')
# Link from a Library .blend file
bpy.ops.wm.link(filepath="", directory="", filename="", files=[], filter_blender=True, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=True, filemode=1, relative_path=True, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', link=True, autoselect=True, active_layer=True, instance_groups=True)
# Print memory statistics to the console
bpy.ops.wm.memory_statistics()
# Open a Blender file
bpy.ops.wm.open_mainfile(filepath="", filter_blender=True, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=8, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', load_ui=True, use_scripts=True)
# List all the Operators in a text-block, useful for scripting
bpy.ops.wm.operator_cheat_sheet()
# Set the active operator to its default values
bpy.ops.wm.operator_defaults()
#
bpy.ops.wm.operator_pie_enum(data_path="", prop_string="")
# Add or remove an Operator Preset
bpy.ops.wm.operator_preset_add(name="", remove_active=False, operator="")
# Open a path in a file browser
bpy.ops.wm.path_open(filepath="")
# Clear selected .blend file's previews
bpy.ops.wm.previews_batch_clear(files=[], directory="", filter_blender=True, filter_folder=True, use_scenes=True, use_groups=True, use_objects=True, use_intern_data=True, use_trusted=False, use_backups=True)
# Generate selected .blend file's previews
bpy.ops.wm.previews_batch_generate(files=[], directory="", filter_blender=True, filter_folder=True, use_scenes=True, use_groups=True, use_objects=True, use_intern_data=True, use_trusted=False, use_backups=True)
# Clear data-block previews (only for some types like objects, materials, textures, etc.)
bpy.ops.wm.previews_clear(id_type={'SCENE', 'GROUP', 'OBJECT', 'MATERIAL', 'LAMP', 'WORLD', 'TEXTURE', 'IMAGE'})
# Ensure data-block previews are available and up-to-date (to be saved in .blend file, only for some types like materials, textures, etc.)
bpy.ops.wm.previews_ensure()
#
bpy.ops.wm.properties_add(data_path="")
# Jump to a different tab inside the properties editor
bpy.ops.wm.properties_context_change(context="")
#
bpy.ops.wm.properties_edit(data_path="", property="", value="", min=-10000, max=10000, use_soft_limits=False, soft_min=-10000, soft_max=10000, description="")
# Internal use (edit a property data_path)
bpy.ops.wm.properties_remove(data_path="", property="")
# Quit Blender
bpy.ops.wm.quit_blender()
# Set some size property (like e.g. brush size) with mouse wheel
bpy.ops.wm.radial_control(data_path_primary="", data_path_secondary="", use_secondary="", rotation_path="", color_path="", fill_color_path="", fill_color_override_path="", fill_color_override_test_path="", zoom_path="", image_id="", secondary_tex=False)
# Load default file and user preferences
bpy.ops.wm.read_factory_settings(app_template="Template", use_empty=False)
# Reloads history and bookmarks
bpy.ops.wm.read_history()
# Open the default file (doesn't save the current file)
bpy.ops.wm.read_homefile(filepath="", load_ui=True, use_empty=False, use_splash=False, app_template="Template")
# Open an automatically saved file to recover it
bpy.ops.wm.recover_auto_save(filepath="", filter_blender=True, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=False, filter_blenlib=False, filemode=8, display_type='LIST_LONG', sort_method='FILE_SORT_TIME')
# Open the last closed file ("quit.blend")
bpy.ops.wm.recover_last_session()
# Simple redraw timer to test the speed of updating the interface
bpy.ops.wm.redraw_timer(type='DRAW', iterations=10, time_limit=0)
# Reload the saved file
bpy.ops.wm.revert_mainfile(use_scripts=True)
# Save the current file in the desired location
bpy.ops.wm.save_as_mainfile(filepath="", check_existing=True, filter_blender=True, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=8, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', compress=False, relative_remap=True, copy=False, use_mesh_compat=False)
# Make the current file the default .blend file, includes preferences
bpy.ops.wm.save_homefile()
# Save the current Blender file
bpy.ops.wm.save_mainfile(filepath="", check_existing=True, filter_blender=True, filter_backup=False, filter_image=False, filter_movie=False, filter_python=False, filter_font=False, filter_sound=False, filter_text=False, filter_btx=False, filter_collada=False, filter_alembic=False, filter_folder=True, filter_blenlib=False, filemode=8, display_type='DEFAULT', sort_method='FILE_SORT_ALPHA', compress=False, relative_remap=False)
# Save user preferences separately, overrides startup file preferences
bpy.ops.wm.save_userpref()
# Pop-up a search menu over all available operators in current context
bpy.ops.wm.search_menu()
# Toggle 3D stereo support for current window (or change the display mode)
bpy.ops.wm.set_stereo_3d(display_mode='ANAGLYPH', anaglyph_type='RED_CYAN', interlace_type='ROW_INTERLEAVED', use_interlace_swap=False, use_sidebyside_crosseyed=False)
# Open the splash screen with release info
bpy.ops.wm.splash()
# Generate system information, saved into a text file
bpy.ops.wm.sysinfo(filepath="")
# Load and apply a Blender XML theme file
bpy.ops.wm.theme_install(overwrite=True, filepath="", filter_folder=True, filter_glob="*.xml")
# Open a website in the web-browser
bpy.ops.wm.url_open(url="")
# Add path to exclude from autoexecution
bpy.ops.wm.userpref_autoexec_path_add()
# Remove path to exclude from autoexecution
bpy.ops.wm.userpref_autoexec_path_remove(index=0)
# Close the current Blender window
bpy.ops.wm.window_close()
# Duplicate the current Blender window
bpy.ops.wm.window_duplicate()
# Toggle the current window fullscreen
bpy.ops.wm.window_fullscreen_toggle()

# Create a new world Data-Block
bpy.ops.world.new()
